{"version":3,"file":"Registry.js","sourceRoot":"","sources":["Registry.ts"],"names":[],"mappings":";;;;;;;;;;;;IAAA,2CAAsC;IACtC,mCAA8B;IAC9B,2CAAuD;IAwBvD;;OAEG;IACU,QAAA,gBAAgB,GAAG,oBAAoB,CAAC;IA8DrD;;;;;OAKG;IACH,SAAgB,uBAAuB,CAAsC,IAAS;QACrF,OAAO,OAAO,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,wBAAgB,CAAC,CAAC;IACzD,CAAC;IAFD,0DAEC;IAED,SAAgB,gBAAgB,CAAC,IAAS;QACzC,OAAO,OAAO,CAAC,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;IACvC,CAAC;IAFD,4CAEC;IAED,SAAgB,cAAc,CAA4B,IAAS;QAClE,IAAI,OAAO,IAAI,KAAK,UAAU,IAAI,IAAI,CAAC,SAAS,EAAE;YACjD,OAAO,IAAI,CAAC;SACZ;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IALD,wCAKC;IAED,SAAgB,QAAQ,CACvB,IAAS;QAET,OAAO,uBAAuB,CAAC,IAAI,CAAC,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC;IAChE,CAAC;IAJD,4BAIC;IAED,SAAgB,gCAAgC,CAC/C,IAAS;QAET,OAAO,OAAO,CACb,IAAI;YACH,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC;YACjC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC;YAC9B,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CACzD,CAAC;IACH,CAAC;IATD,4EASC;IAED;;OAEG;IACH;QAA8B,oCAA+C;QAA7E;;QA8HA,CAAC;QAtHA;;WAEG;QACK,kCAAe,GAAvB,UACC,WAA0B,EAC1B,IAA8D;YAE9D,IAAI,CAAC,IAAI,CAAC;gBACT,IAAI,EAAE,WAAW;gBACjB,MAAM,EAAE,QAAQ;gBAChB,IAAI,MAAA;aACJ,CAAC,CAAC;QACJ,CAAC;QAEM,yBAAM,GAAb,UAAc,KAAoB,EAAE,IAAkB;YAAtD,iBAyBC;YAxBA,IAAI,IAAI,CAAC,eAAe,KAAK,SAAS,EAAE;gBACvC,IAAI,CAAC,eAAe,GAAG,IAAI,aAAG,EAAE,CAAC;aACjC;YAED,IAAI,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;gBACpC,MAAM,IAAI,KAAK,CAAC,6CAA2C,KAAK,CAAC,QAAQ,EAAE,MAAG,CAAC,CAAC;aAChF;YAED,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YAEtC,IAAI,IAAI,YAAY,iBAAO,EAAE;gBAC5B,IAAI,CAAC,IAAI,CACR,UAAC,UAAU;oBACV,KAAI,CAAC,eAAgB,CAAC,GAAG,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;oBAC7C,KAAI,CAAC,eAAe,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;oBACxC,OAAO,UAAU,CAAC;gBACnB,CAAC,EACD,UAAC,KAAK;oBACL,MAAM,KAAK,CAAC;gBACb,CAAC,CACD,CAAC;aACF;iBAAM,IAAI,uBAAuB,CAAC,IAAI,CAAC,EAAE;gBACzC,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aAClC;QACF,CAAC;QAEM,iCAAc,GAArB,UAAsB,KAAoB,EAAE,eAAgC;YAC3E,IAAI,IAAI,CAAC,iBAAiB,KAAK,SAAS,EAAE;gBACzC,IAAI,CAAC,iBAAiB,GAAG,IAAI,aAAG,EAAE,CAAC;aACnC;YAED,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;gBACtC,MAAM,IAAI,KAAK,CAAC,+CAA6C,KAAK,CAAC,QAAQ,EAAE,MAAG,CAAC,CAAC;aAClF;YAED,IAAM,WAAW,GAAG,IAAI,iBAAO,EAAE,CAAC;YAElC,IAAM,YAAY,GAAiB;gBAClC,QAAQ,EAAE,eAAe,CAAC,cAAM,OAAA,WAAW,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC,EAAxC,CAAwC,CAAC;gBACzE,WAAW,aAAA;aACX,CAAC;YAEF,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;YAChD,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;QAC3C,CAAC;QAMM,sBAAG,GAAV,UACC,KAAoB;YADrB,iBAoCC;YAjCA,IAAI,CAAC,IAAI,CAAC,eAAe,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;gBAC9C,OAAO,IAAI,CAAC;aACZ;YAED,IAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAE7C,IAAI,QAAQ,CAAI,IAAI,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;gBAC9C,OAAO,IAAI,CAAC;aACZ;YAED,IAAI,IAAI,YAAY,iBAAO,EAAE;gBAC5B,OAAO,IAAI,CAAC;aACZ;YAED,IAAM,OAAO,GAAmC,IAAK,EAAE,CAAC;YACxD,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YAEzC,OAAO,CAAC,IAAI,CACX,UAAC,UAAU;gBACV,IAAI,gCAAgC,CAAI,UAAU,CAAC,EAAE;oBACpD,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC;iBAChC;gBAED,KAAI,CAAC,eAAgB,CAAC,GAAG,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;gBAC7C,KAAI,CAAC,eAAe,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;gBACxC,OAAO,UAAU,CAAC;YACnB,CAAC,EACD,UAAC,KAAK;gBACL,MAAM,KAAK,CAAC;YACb,CAAC,CACD,CAAC;YAEF,OAAO,IAAI,CAAC;QACb,CAAC;QAEM,8BAAW,GAAlB,UAAsB,KAAoB;YACzC,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;gBACxD,OAAO,IAAI,CAAC;aACZ;YAED,OAAO,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC;QAC3C,CAAC;QAEM,sBAAG,GAAV,UAAW,KAAoB;YAC9B,OAAO,OAAO,CAAC,IAAI,CAAC,eAAe,IAAI,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;QACzE,CAAC;QAEM,8BAAW,GAAlB,UAAmB,KAAoB;YACtC,OAAO,OAAO,CAAC,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;QAC7E,CAAC;QACF,eAAC;IAAD,CAAC,AA9HD,CAA8B,iBAAO,GA8HpC;IA9HY,4BAAQ;IAgIrB,kBAAe,QAAQ,CAAC","sourcesContent":["import Promise from '../shim/Promise';\nimport Map from '../shim/Map';\nimport { Evented, EventObject } from '../core/Evented';\nimport {\n\tConstructor,\n\tInjectorFactory,\n\tInjectorItem,\n\tRegistryLabel,\n\tWidgetBaseConstructor,\n\tWidgetBaseInterface,\n\tESMDefaultWidgetBase,\n\tWidgetBaseConstructorFunction,\n\tESMDefaultWidgetBaseFunction,\n\tCallback,\n\tWNodeFactory,\n\tRenderResult,\n\tWidgetBaseTypes\n} from './interfaces';\n\nexport type RegistryItem =\n\t| WidgetBaseConstructor\n\t| WNodeFactory<any>\n\t| Promise<WidgetBaseConstructor | WNodeFactory<any>>\n\t| WidgetBaseConstructorFunction\n\t| ESMDefaultWidgetBaseFunction;\n\n/**\n * Widget base type\n */\nexport const WIDGET_BASE_TYPE = '__widget_base_type';\n\nexport interface RegistryEventObject extends EventObject<RegistryLabel> {\n\taction: string;\n\titem: WNodeFactory<any> | WidgetBaseConstructor | InjectorItem;\n}\n/**\n * Widget Registry Interface\n */\nexport interface RegistryInterface {\n\t/**\n\t * Define a WidgetRegistryItem against a label\n\t *\n\t * @param label The label of the widget to register\n\t * @param registryItem The registry item to define\n\t */\n\tdefine(label: RegistryLabel, registryItem: RegistryItem): void;\n\n\t/**\n\t * Return a RegistryItem for the given label, null if an entry doesn't exist\n\t *\n\t * @param widgetLabel The label of the widget to return\n\t * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n\t */\n\tget(label: RegistryLabel): WNodeFactory<any> | Callback<any, any, RenderResult> | Constructor<any> | null;\n\tget<T extends WNodeFactory<any>>(label: RegistryLabel): T | null;\n\tget<T extends Callback<any, any, RenderResult>>(label: RegistryLabel): T | null;\n\tget<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null;\n\n\t/**\n\t * Returns a boolean if an entry for the label exists\n\t *\n\t * @param widgetLabel The label to search for\n\t * @returns boolean indicating if a widget registry item exists\n\t */\n\thas(label: RegistryLabel): boolean;\n\n\t/**\n\t * Define an Injector against a label\n\t *\n\t * @param label The label of the injector to register\n\t * @param registryItem The injector factory\n\t */\n\tdefineInjector(label: RegistryLabel, injectorFactory: InjectorFactory): void;\n\n\t/**\n\t * Return an Injector registry item for the given label, null if an entry doesn't exist\n\t *\n\t * @param label The label of the injector to return\n\t * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n\t */\n\tgetInjector<T>(label: RegistryLabel): InjectorItem<T> | null;\n\n\t/**\n\t * Returns a boolean if an injector for the label exists\n\t *\n\t * @param widgetLabel The label to search for\n\t * @returns boolean indicating if a injector registry item exists\n\t */\n\thasInjector(label: RegistryLabel): boolean;\n}\n\n/**\n * Checks is the item is a subclass of WidgetBase (or a WidgetBase)\n *\n * @param item the item to check\n * @returns true/false indicating if the item is a WidgetBaseConstructor\n */\nexport function isWidgetBaseConstructor<T extends WidgetBaseInterface = any>(item: any): item is Constructor<T> {\n\treturn Boolean(item && item._type === WIDGET_BASE_TYPE);\n}\n\nexport function isWidgetFunction(item: any): item is Callback<any, any, RenderResult> {\n\treturn Boolean(item && item.isWidget);\n}\n\nexport function isWNodeFactory<W extends WidgetBaseTypes>(node: any): node is WNodeFactory<W> {\n\tif (typeof node === 'function' && node.isFactory) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function isWidget<T extends WidgetBaseInterface = any>(\n\titem: any\n): item is Constructor<T> | Callback<any, any, RenderResult> {\n\treturn isWidgetBaseConstructor(item) || isWidgetFunction(item);\n}\n\nexport function isWidgetConstructorDefaultExport<T extends WidgetBaseTypes>(\n\titem: any\n): item is ESMDefaultWidgetBase<T> {\n\treturn Boolean(\n\t\titem &&\n\t\t\titem.hasOwnProperty('__esModule') &&\n\t\t\titem.hasOwnProperty('default') &&\n\t\t\t(isWidget(item.default) || isWNodeFactory(item.default))\n\t);\n}\n\n/**\n * The Registry implementation\n */\nexport class Registry extends Evented<{}, RegistryLabel, RegistryEventObject> implements RegistryInterface {\n\t/**\n\t * internal map of labels and RegistryItem\n\t */\n\tprivate _widgetRegistry: Map<RegistryLabel, RegistryItem> | undefined;\n\n\tprivate _injectorRegistry: Map<RegistryLabel, InjectorItem> | undefined;\n\n\t/**\n\t * Emit loaded event for registry label\n\t */\n\tprivate emitLoadedEvent(\n\t\twidgetLabel: RegistryLabel,\n\t\titem: WNodeFactory<any> | WidgetBaseConstructor | InjectorItem\n\t): void {\n\t\tthis.emit({\n\t\t\ttype: widgetLabel,\n\t\t\taction: 'loaded',\n\t\t\titem\n\t\t});\n\t}\n\n\tpublic define(label: RegistryLabel, item: RegistryItem): void {\n\t\tif (this._widgetRegistry === undefined) {\n\t\t\tthis._widgetRegistry = new Map();\n\t\t}\n\n\t\tif (this._widgetRegistry.has(label)) {\n\t\t\tthrow new Error(`widget has already been registered for '${label.toString()}'`);\n\t\t}\n\n\t\tthis._widgetRegistry.set(label, item);\n\n\t\tif (item instanceof Promise) {\n\t\t\titem.then(\n\t\t\t\t(widgetCtor) => {\n\t\t\t\t\tthis._widgetRegistry!.set(label, widgetCtor);\n\t\t\t\t\tthis.emitLoadedEvent(label, widgetCtor);\n\t\t\t\t\treturn widgetCtor;\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t);\n\t\t} else if (isWidgetBaseConstructor(item)) {\n\t\t\tthis.emitLoadedEvent(label, item);\n\t\t}\n\t}\n\n\tpublic defineInjector(label: RegistryLabel, injectorFactory: InjectorFactory): void {\n\t\tif (this._injectorRegistry === undefined) {\n\t\t\tthis._injectorRegistry = new Map();\n\t\t}\n\n\t\tif (this._injectorRegistry.has(label)) {\n\t\t\tthrow new Error(`injector has already been registered for '${label.toString()}'`);\n\t\t}\n\n\t\tconst invalidator = new Evented();\n\n\t\tconst injectorItem: InjectorItem = {\n\t\t\tinjector: injectorFactory(() => invalidator.emit({ type: 'invalidate' })),\n\t\t\tinvalidator\n\t\t};\n\n\t\tthis._injectorRegistry.set(label, injectorItem);\n\t\tthis.emitLoadedEvent(label, injectorItem);\n\t}\n\n\tpublic get(label: RegistryLabel): WNodeFactory<any> | Callback<any, any, RenderResult> | Constructor<any> | null;\n\tpublic get<T extends WNodeFactory<any>>(label: RegistryLabel): T | null;\n\tpublic get<T extends Callback<any, any, RenderResult>>(label: RegistryLabel): T | null;\n\tpublic get<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null;\n\tpublic get<T extends WidgetBaseInterface = WidgetBaseInterface>(\n\t\tlabel: RegistryLabel\n\t): WNodeFactory<T> | Callback<any, any, RenderResult> | Constructor<T> | null {\n\t\tif (!this._widgetRegistry || !this.has(label)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst item = this._widgetRegistry.get(label);\n\n\t\tif (isWidget<T>(item) || isWNodeFactory(item)) {\n\t\t\treturn item;\n\t\t}\n\n\t\tif (item instanceof Promise) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst promise = (<WidgetBaseConstructorFunction>item)();\n\t\tthis._widgetRegistry.set(label, promise);\n\n\t\tpromise.then(\n\t\t\t(widgetCtor) => {\n\t\t\t\tif (isWidgetConstructorDefaultExport<T>(widgetCtor)) {\n\t\t\t\t\twidgetCtor = widgetCtor.default;\n\t\t\t\t}\n\n\t\t\t\tthis._widgetRegistry!.set(label, widgetCtor);\n\t\t\t\tthis.emitLoadedEvent(label, widgetCtor);\n\t\t\t\treturn widgetCtor;\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\n\t\treturn null;\n\t}\n\n\tpublic getInjector<T>(label: RegistryLabel): InjectorItem<T> | null {\n\t\tif (!this._injectorRegistry || !this.hasInjector(label)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._injectorRegistry.get(label)!;\n\t}\n\n\tpublic has(label: RegistryLabel): boolean {\n\t\treturn Boolean(this._widgetRegistry && this._widgetRegistry.has(label));\n\t}\n\n\tpublic hasInjector(label: RegistryLabel): boolean {\n\t\treturn Boolean(this._injectorRegistry && this._injectorRegistry.has(label));\n\t}\n}\n\nexport default Registry;\n"]}