{"version":3,"file":"Registry.mjs","sourceRoot":"","sources":["Registry.ts"],"names":[],"mappings":"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","sourcesContent":["import Promise from '../shim/Promise';\nimport Map from '../shim/Map';\nimport { Evented, EventObject } from '../core/Evented';\nimport {\n\tConstructor,\n\tInjectorFactory,\n\tInjectorItem,\n\tRegistryLabel,\n\tWidgetBaseConstructor,\n\tWidgetBaseInterface,\n\tESMDefaultWidgetBase,\n\tWidgetBaseConstructorFunction,\n\tESMDefaultWidgetBaseFunction,\n\tCallback,\n\tWNodeFactory,\n\tRenderResult,\n\tWidgetBaseTypes\n} from './interfaces';\n\nexport type RegistryItem =\n\t| WidgetBaseConstructor\n\t| WNodeFactory<any>\n\t| Promise<WidgetBaseConstructor | WNodeFactory<any>>\n\t| WidgetBaseConstructorFunction\n\t| ESMDefaultWidgetBaseFunction;\n\n/**\n * Widget base type\n */\nexport const WIDGET_BASE_TYPE = '__widget_base_type';\n\nexport interface RegistryEventObject extends EventObject<RegistryLabel> {\n\taction: string;\n\titem: WNodeFactory<any> | WidgetBaseConstructor | InjectorItem;\n}\n/**\n * Widget Registry Interface\n */\nexport interface RegistryInterface {\n\t/**\n\t * Define a WidgetRegistryItem against a label\n\t *\n\t * @param label The label of the widget to register\n\t * @param registryItem The registry item to define\n\t */\n\tdefine(label: RegistryLabel, registryItem: RegistryItem): void;\n\n\t/**\n\t * Return a RegistryItem for the given label, null if an entry doesn't exist\n\t *\n\t * @param widgetLabel The label of the widget to return\n\t * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n\t */\n\tget(label: RegistryLabel): WNodeFactory<any> | Callback<any, any, RenderResult> | Constructor<any> | null;\n\tget<T extends WNodeFactory<any>>(label: RegistryLabel): T | null;\n\tget<T extends Callback<any, any, RenderResult>>(label: RegistryLabel): T | null;\n\tget<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null;\n\n\t/**\n\t * Returns a boolean if an entry for the label exists\n\t *\n\t * @param widgetLabel The label to search for\n\t * @returns boolean indicating if a widget registry item exists\n\t */\n\thas(label: RegistryLabel): boolean;\n\n\t/**\n\t * Define an Injector against a label\n\t *\n\t * @param label The label of the injector to register\n\t * @param registryItem The injector factory\n\t */\n\tdefineInjector(label: RegistryLabel, injectorFactory: InjectorFactory): void;\n\n\t/**\n\t * Return an Injector registry item for the given label, null if an entry doesn't exist\n\t *\n\t * @param label The label of the injector to return\n\t * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n\t */\n\tgetInjector<T>(label: RegistryLabel): InjectorItem<T> | null;\n\n\t/**\n\t * Returns a boolean if an injector for the label exists\n\t *\n\t * @param widgetLabel The label to search for\n\t * @returns boolean indicating if a injector registry item exists\n\t */\n\thasInjector(label: RegistryLabel): boolean;\n}\n\n/**\n * Checks is the item is a subclass of WidgetBase (or a WidgetBase)\n *\n * @param item the item to check\n * @returns true/false indicating if the item is a WidgetBaseConstructor\n */\nexport function isWidgetBaseConstructor<T extends WidgetBaseInterface = any>(item: any): item is Constructor<T> {\n\treturn Boolean(item && item._type === WIDGET_BASE_TYPE);\n}\n\nexport function isWidgetFunction(item: any): item is Callback<any, any, RenderResult> {\n\treturn Boolean(item && item.isWidget);\n}\n\nexport function isWNodeFactory<W extends WidgetBaseTypes>(node: any): node is WNodeFactory<W> {\n\tif (typeof node === 'function' && node.isFactory) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function isWidget<T extends WidgetBaseInterface = any>(\n\titem: any\n): item is Constructor<T> | Callback<any, any, RenderResult> {\n\treturn isWidgetBaseConstructor(item) || isWidgetFunction(item);\n}\n\nexport function isWidgetConstructorDefaultExport<T extends WidgetBaseTypes>(\n\titem: any\n): item is ESMDefaultWidgetBase<T> {\n\treturn Boolean(\n\t\titem &&\n\t\t\titem.hasOwnProperty('__esModule') &&\n\t\t\titem.hasOwnProperty('default') &&\n\t\t\t(isWidget(item.default) || isWNodeFactory(item.default))\n\t);\n}\n\n/**\n * The Registry implementation\n */\nexport class Registry extends Evented<{}, RegistryLabel, RegistryEventObject> implements RegistryInterface {\n\t/**\n\t * internal map of labels and RegistryItem\n\t */\n\tprivate _widgetRegistry: Map<RegistryLabel, RegistryItem> | undefined;\n\n\tprivate _injectorRegistry: Map<RegistryLabel, InjectorItem> | undefined;\n\n\t/**\n\t * Emit loaded event for registry label\n\t */\n\tprivate emitLoadedEvent(\n\t\twidgetLabel: RegistryLabel,\n\t\titem: WNodeFactory<any> | WidgetBaseConstructor | InjectorItem\n\t): void {\n\t\tthis.emit({\n\t\t\ttype: widgetLabel,\n\t\t\taction: 'loaded',\n\t\t\titem\n\t\t});\n\t}\n\n\tpublic define(label: RegistryLabel, item: RegistryItem): void {\n\t\tif (this._widgetRegistry === undefined) {\n\t\t\tthis._widgetRegistry = new Map();\n\t\t}\n\n\t\tif (this._widgetRegistry.has(label)) {\n\t\t\tthrow new Error(`widget has already been registered for '${label.toString()}'`);\n\t\t}\n\n\t\tthis._widgetRegistry.set(label, item);\n\n\t\tif (item instanceof Promise) {\n\t\t\titem.then(\n\t\t\t\t(widgetCtor) => {\n\t\t\t\t\tthis._widgetRegistry!.set(label, widgetCtor);\n\t\t\t\t\tthis.emitLoadedEvent(label, widgetCtor);\n\t\t\t\t\treturn widgetCtor;\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t);\n\t\t} else if (isWidgetBaseConstructor(item)) {\n\t\t\tthis.emitLoadedEvent(label, item);\n\t\t}\n\t}\n\n\tpublic defineInjector(label: RegistryLabel, injectorFactory: InjectorFactory): void {\n\t\tif (this._injectorRegistry === undefined) {\n\t\t\tthis._injectorRegistry = new Map();\n\t\t}\n\n\t\tif (this._injectorRegistry.has(label)) {\n\t\t\tthrow new Error(`injector has already been registered for '${label.toString()}'`);\n\t\t}\n\n\t\tconst invalidator = new Evented();\n\n\t\tconst injectorItem: InjectorItem = {\n\t\t\tinjector: injectorFactory(() => invalidator.emit({ type: 'invalidate' })),\n\t\t\tinvalidator\n\t\t};\n\n\t\tthis._injectorRegistry.set(label, injectorItem);\n\t\tthis.emitLoadedEvent(label, injectorItem);\n\t}\n\n\tpublic get(label: RegistryLabel): WNodeFactory<any> | Callback<any, any, RenderResult> | Constructor<any> | null;\n\tpublic get<T extends WNodeFactory<any>>(label: RegistryLabel): T | null;\n\tpublic get<T extends Callback<any, any, RenderResult>>(label: RegistryLabel): T | null;\n\tpublic get<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null;\n\tpublic get<T extends WidgetBaseInterface = WidgetBaseInterface>(\n\t\tlabel: RegistryLabel\n\t): WNodeFactory<T> | Callback<any, any, RenderResult> | Constructor<T> | null {\n\t\tif (!this._widgetRegistry || !this.has(label)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst item = this._widgetRegistry.get(label);\n\n\t\tif (isWidget<T>(item) || isWNodeFactory(item)) {\n\t\t\treturn item;\n\t\t}\n\n\t\tif (item instanceof Promise) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst promise = (<WidgetBaseConstructorFunction>item)();\n\t\tthis._widgetRegistry.set(label, promise);\n\n\t\tpromise.then(\n\t\t\t(widgetCtor) => {\n\t\t\t\tif (isWidgetConstructorDefaultExport<T>(widgetCtor)) {\n\t\t\t\t\twidgetCtor = widgetCtor.default;\n\t\t\t\t}\n\n\t\t\t\tthis._widgetRegistry!.set(label, widgetCtor);\n\t\t\t\tthis.emitLoadedEvent(label, widgetCtor);\n\t\t\t\treturn widgetCtor;\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\n\t\treturn null;\n\t}\n\n\tpublic getInjector<T>(label: RegistryLabel): InjectorItem<T> | null {\n\t\tif (!this._injectorRegistry || !this.hasInjector(label)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._injectorRegistry.get(label)!;\n\t}\n\n\tpublic has(label: RegistryLabel): boolean {\n\t\treturn Boolean(this._widgetRegistry && this._widgetRegistry.has(label));\n\t}\n\n\tpublic hasInjector(label: RegistryLabel): boolean {\n\t\treturn Boolean(this._injectorRegistry && this._injectorRegistry.has(label));\n\t}\n}\n\nexport default Registry;\n"]}