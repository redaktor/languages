{"version":3,"file":"icache.js","sourceRoot":"","sources":["icache.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA,mCAAmC;IACnC,gCAA8C;IAC9C,iCAA4B;IAE5B,IAAM,OAAO,GAAG,aAAM,CAAC,EAAE,KAAK,iBAAA,EAAE,WAAW,oBAAA,EAAE,CAAC,CAAC;IAgC/C,SAAgB,sBAAsB;QACrC,IAAM,MAAM,GAAG,OAAO,CACrB,UAAC,EAAsC;gBAApC,kBAAkC,EAApB,4BAAW,EAAE,gBAAK;YAClC,OAAO;gBACN,QAAQ,EAAR,UAAS,GAAQ,EAAE,KAAU;oBAC5B,IAAI,WAAW,GAAG,KAAK,CAAC,GAAG,CAAe,GAAG,CAAC,CAAC;oBAC/C,IAAI,CAAC,WAAW,EAAE;wBACjB,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;qBACrB;oBACD,WAAW,GAAG,KAAK,CAAC,GAAG,CAAe,GAAG,CAAC,CAAC;oBAC3C,IAAI,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,KAAK,SAAS,EAAE;wBACrD,OAAO,SAAS,CAAC;qBACjB;oBACD,OAAO,WAAW,CAAC,KAAK,CAAC;gBAC1B,CAAC;gBACD,GAAG,EAAH,UAAI,GAAQ;oBACX,IAAM,WAAW,GAAG,KAAK,CAAC,GAAG,CAAe,GAAG,CAAC,CAAC;oBACjD,IAAI,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,KAAK,SAAS,EAAE;wBACrD,OAAO,SAAS,CAAC;qBACjB;oBACD,OAAO,WAAW,CAAC,KAAK,CAAC;gBAC1B,CAAC;gBACD,GAAG,EAAH,UAAI,GAAQ,EAAE,KAAU;oBACvB,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;wBAChC,KAAK,GAAG,KAAK,EAAE,CAAC;wBAChB,IAAI,KAAK,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;4BAC9C,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;gCACd,MAAM,EAAE,SAAS;gCACjB,KAAK,OAAA;6BACL,CAAC,CAAC;4BACH,KAAK,CAAC,IAAI,CAAC,UAAC,MAAW;gCACtB,IAAM,WAAW,GAAG,KAAK,CAAC,GAAG,CAAe,GAAG,CAAC,CAAC;gCACjD,IAAI,WAAW,IAAI,WAAW,CAAC,KAAK,KAAK,KAAK,EAAE;oCAC/C,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;wCACd,MAAM,EAAE,UAAU;wCAClB,KAAK,EAAE,MAAM;qCACb,CAAC,CAAC;oCACH,WAAW,EAAE,CAAC;iCACd;4BACF,CAAC,CAAC,CAAC;4BACH,OAAO;yBACP;qBACD;oBACD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;wBACd,MAAM,EAAE,UAAU;wBAClB,KAAK,OAAA;qBACL,CAAC,CAAC;oBACH,WAAW,EAAE,CAAC;gBACf,CAAC;gBACD,KAAK,EAAL;oBACC,KAAK,CAAC,KAAK,EAAE,CAAC;gBACf,CAAC;aACD,CAAC;QACH,CAAC,CACD,CAAC;QACF,OAAO,MAAM,CAAC;IACf,CAAC;IAxDD,wDAwDC;IAEY,QAAA,MAAM,GAAG,sBAAsB,EAAE,CAAC;IAE/C,kBAAe,cAAM,CAAC","sourcesContent":["/* tslint:disable:interface-name */\nimport { create, invalidator } from '../vdom';\nimport cache from './cache';\n\nconst factory = create({ cache, invalidator });\n\ninterface CacheWrapper {\n\tstatus: 'pending' | 'resolved';\n\tvalue: any;\n}\n\nexport interface ICacheResult<S = void> {\n\tgetOrSet: {\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? () => Promise<T> : () => Promise<S[T]>\n\t\t): void extends S ? undefined | T : undefined | S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? () => T : () => S[T]\n\t\t): void extends S ? T : S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? T : S[T]\n\t\t): void extends S ? T : S[T];\n\t};\n\tget<T extends void extends S ? any : keyof S>(\n\t\tkey: void extends S ? any : T\n\t): void extends S ? T | undefined : S[T] | undefined;\n\tset<T extends void extends S ? any : keyof S>(\n\t\tkey: void extends S ? any : T,\n\t\tvalue: void extends S ? T : S[T]\n\t): void;\n\tclear(): void;\n}\n\nexport function createICacheMiddleware<S = void>() {\n\tconst icache = factory(\n\t\t({ middleware: { invalidator, cache } }): ICacheResult<S> => {\n\t\t\treturn {\n\t\t\t\tgetOrSet(key: any, value: any): any | undefined {\n\t\t\t\t\tlet cachedValue = cache.get<CacheWrapper>(key);\n\t\t\t\t\tif (!cachedValue) {\n\t\t\t\t\t\tthis.set(key, value);\n\t\t\t\t\t}\n\t\t\t\t\tcachedValue = cache.get<CacheWrapper>(key);\n\t\t\t\t\tif (!cachedValue || cachedValue.status === 'pending') {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\treturn cachedValue.value;\n\t\t\t\t},\n\t\t\t\tget(key: any): any {\n\t\t\t\t\tconst cachedValue = cache.get<CacheWrapper>(key);\n\t\t\t\t\tif (!cachedValue || cachedValue.status === 'pending') {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\treturn cachedValue.value;\n\t\t\t\t},\n\t\t\t\tset(key: any, value: any): void {\n\t\t\t\t\tif (typeof value === 'function') {\n\t\t\t\t\t\tvalue = value();\n\t\t\t\t\t\tif (value && typeof value.then === 'function') {\n\t\t\t\t\t\t\tcache.set(key, {\n\t\t\t\t\t\t\t\tstatus: 'pending',\n\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tvalue.then((result: any) => {\n\t\t\t\t\t\t\t\tconst cachedValue = cache.get<CacheWrapper>(key);\n\t\t\t\t\t\t\t\tif (cachedValue && cachedValue.value === value) {\n\t\t\t\t\t\t\t\t\tcache.set(key, {\n\t\t\t\t\t\t\t\t\t\tstatus: 'resolved',\n\t\t\t\t\t\t\t\t\t\tvalue: result\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tinvalidator();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcache.set(key, {\n\t\t\t\t\t\tstatus: 'resolved',\n\t\t\t\t\t\tvalue\n\t\t\t\t\t});\n\t\t\t\t\tinvalidator();\n\t\t\t\t},\n\t\t\t\tclear(): void {\n\t\t\t\t\tcache.clear();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t);\n\treturn icache;\n}\n\nexport const icache = createICacheMiddleware();\n\nexport default icache;\n"]}