{"version":3,"file":"icache.mjs","sourceRoot":"","sources":["icache.ts"],"names":[],"mappings":"AAAA,mCAAmC;AACnC,OAAO,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAC9C,OAAO,KAAK,MAAM,SAAS,CAAC;AAE5B,MAAM,OAAO,GAAG,MAAM,CAAC,EAAE,KAAK,EAAE,WAAW,EAAE,CAAC,CAAC;AAgC/C,MAAM,UAAU,sBAAsB;IACrC,MAAM,MAAM,GAAG,OAAO,CACrB,CAAC,EAAE,UAAU,EAAE,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAmB,EAAE;QAC3D,OAAO;YACN,QAAQ,CAAC,GAAQ,EAAE,KAAU;gBAC5B,IAAI,WAAW,GAAG,KAAK,CAAC,GAAG,CAAe,GAAG,CAAC,CAAC;gBAC/C,IAAI,CAAC,WAAW,EAAE;oBACjB,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;iBACrB;gBACD,WAAW,GAAG,KAAK,CAAC,GAAG,CAAe,GAAG,CAAC,CAAC;gBAC3C,IAAI,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,KAAK,SAAS,EAAE;oBACrD,OAAO,SAAS,CAAC;iBACjB;gBACD,OAAO,WAAW,CAAC,KAAK,CAAC;YAC1B,CAAC;YACD,GAAG,CAAC,GAAQ;gBACX,MAAM,WAAW,GAAG,KAAK,CAAC,GAAG,CAAe,GAAG,CAAC,CAAC;gBACjD,IAAI,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,KAAK,SAAS,EAAE;oBACrD,OAAO,SAAS,CAAC;iBACjB;gBACD,OAAO,WAAW,CAAC,KAAK,CAAC;YAC1B,CAAC;YACD,GAAG,CAAC,GAAQ,EAAE,KAAU;gBACvB,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;oBAChC,KAAK,GAAG,KAAK,EAAE,CAAC;oBAChB,IAAI,KAAK,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC9C,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;4BACd,MAAM,EAAE,SAAS;4BACjB,KAAK;yBACL,CAAC,CAAC;wBACH,KAAK,CAAC,IAAI,CAAC,CAAC,MAAW,EAAE,EAAE;4BAC1B,MAAM,WAAW,GAAG,KAAK,CAAC,GAAG,CAAe,GAAG,CAAC,CAAC;4BACjD,IAAI,WAAW,IAAI,WAAW,CAAC,KAAK,KAAK,KAAK,EAAE;gCAC/C,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;oCACd,MAAM,EAAE,UAAU;oCAClB,KAAK,EAAE,MAAM;iCACb,CAAC,CAAC;gCACH,WAAW,EAAE,CAAC;6BACd;wBACF,CAAC,CAAC,CAAC;wBACH,OAAO;qBACP;iBACD;gBACD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;oBACd,MAAM,EAAE,UAAU;oBAClB,KAAK;iBACL,CAAC,CAAC;gBACH,WAAW,EAAE,CAAC;YACf,CAAC;YACD,KAAK;gBACJ,KAAK,CAAC,KAAK,EAAE,CAAC;YACf,CAAC;SACD,CAAC;IACH,CAAC,CACD,CAAC;IACF,OAAO,MAAM,CAAC;AACf,CAAC;AAED,MAAM,CAAC,MAAM,MAAM,GAAG,sBAAsB,EAAE,CAAC;AAE/C,eAAe,MAAM,CAAC","sourcesContent":["/* tslint:disable:interface-name */\nimport { create, invalidator } from '../vdom';\nimport cache from './cache';\n\nconst factory = create({ cache, invalidator });\n\ninterface CacheWrapper {\n\tstatus: 'pending' | 'resolved';\n\tvalue: any;\n}\n\nexport interface ICacheResult<S = void> {\n\tgetOrSet: {\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? () => Promise<T> : () => Promise<S[T]>\n\t\t): void extends S ? undefined | T : undefined | S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? () => T : () => S[T]\n\t\t): void extends S ? T : S[T];\n\t\t<T extends void extends S ? any : keyof S>(\n\t\t\tkey: void extends S ? any : T,\n\t\t\tvalue: void extends S ? T : S[T]\n\t\t): void extends S ? T : S[T];\n\t};\n\tget<T extends void extends S ? any : keyof S>(\n\t\tkey: void extends S ? any : T\n\t): void extends S ? T | undefined : S[T] | undefined;\n\tset<T extends void extends S ? any : keyof S>(\n\t\tkey: void extends S ? any : T,\n\t\tvalue: void extends S ? T : S[T]\n\t): void;\n\tclear(): void;\n}\n\nexport function createICacheMiddleware<S = void>() {\n\tconst icache = factory(\n\t\t({ middleware: { invalidator, cache } }): ICacheResult<S> => {\n\t\t\treturn {\n\t\t\t\tgetOrSet(key: any, value: any): any | undefined {\n\t\t\t\t\tlet cachedValue = cache.get<CacheWrapper>(key);\n\t\t\t\t\tif (!cachedValue) {\n\t\t\t\t\t\tthis.set(key, value);\n\t\t\t\t\t}\n\t\t\t\t\tcachedValue = cache.get<CacheWrapper>(key);\n\t\t\t\t\tif (!cachedValue || cachedValue.status === 'pending') {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\treturn cachedValue.value;\n\t\t\t\t},\n\t\t\t\tget(key: any): any {\n\t\t\t\t\tconst cachedValue = cache.get<CacheWrapper>(key);\n\t\t\t\t\tif (!cachedValue || cachedValue.status === 'pending') {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\treturn cachedValue.value;\n\t\t\t\t},\n\t\t\t\tset(key: any, value: any): void {\n\t\t\t\t\tif (typeof value === 'function') {\n\t\t\t\t\t\tvalue = value();\n\t\t\t\t\t\tif (value && typeof value.then === 'function') {\n\t\t\t\t\t\t\tcache.set(key, {\n\t\t\t\t\t\t\t\tstatus: 'pending',\n\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tvalue.then((result: any) => {\n\t\t\t\t\t\t\t\tconst cachedValue = cache.get<CacheWrapper>(key);\n\t\t\t\t\t\t\t\tif (cachedValue && cachedValue.value === value) {\n\t\t\t\t\t\t\t\t\tcache.set(key, {\n\t\t\t\t\t\t\t\t\t\tstatus: 'resolved',\n\t\t\t\t\t\t\t\t\t\tvalue: result\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tinvalidator();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcache.set(key, {\n\t\t\t\t\t\tstatus: 'resolved',\n\t\t\t\t\t\tvalue\n\t\t\t\t\t});\n\t\t\t\t\tinvalidator();\n\t\t\t\t},\n\t\t\t\tclear(): void {\n\t\t\t\t\tcache.clear();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t);\n\treturn icache;\n}\n\nexport const icache = createICacheMiddleware();\n\nexport default icache;\n"]}