(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../../shim/WeakMap", "../../shim/IntersectionObserver", "../vdom", "./cache"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var WeakMap_1 = require("../../shim/WeakMap");
    var IntersectionObserver_1 = require("../../shim/IntersectionObserver");
    var vdom_1 = require("../vdom");
    var cache_1 = require("./cache");
    var defaultIntersection = Object.freeze({
        intersectionRatio: 0,
        isIntersecting: false
    });
    var factory = vdom_1.create({ cache: cache_1.default, node: vdom_1.node, invalidator: vdom_1.invalidator, destroy: vdom_1.destroy });
    exports.intersection = factory(function (_a) {
        var _b = _a.middleware, cache = _b.cache, node = _b.node, invalidator = _b.invalidator, destroy = _b.destroy;
        var handles = [];
        destroy(function () {
            var handle;
            while ((handle = handles.pop())) {
                handle && handle();
            }
        });
        function _createDetails(options, rootNode) {
            var entries = new WeakMap_1.default();
            var observer = new IntersectionObserver_1.default(_onIntersect(entries), tslib_1.__assign({}, options, { root: rootNode }));
            var details = tslib_1.__assign({ observer: observer, entries: entries }, options);
            cache.set(JSON.stringify(options), details);
            handles.push(function () { return observer.disconnect(); });
            return details;
        }
        function _getDetails(options) {
            if (options === void 0) { options = {}; }
            return cache.get(JSON.stringify(options));
        }
        function _onIntersect(detailEntries) {
            return function (entries) {
                var e_1, _a;
                try {
                    for (var entries_1 = tslib_1.__values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                        var _b = entries_1_1.value, intersectionRatio = _b.intersectionRatio, isIntersecting = _b.isIntersecting, target = _b.target;
                        detailEntries.set(target, { intersectionRatio: intersectionRatio, isIntersecting: isIntersecting });
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                invalidator();
            };
        }
        return {
            get: function (key, options) {
                if (options === void 0) { options = {}; }
                var rootNode;
                if (options.root) {
                    rootNode = node.get(options.root);
                    if (!rootNode) {
                        return defaultIntersection;
                    }
                }
                var domNode = node.get(key);
                if (!domNode) {
                    return defaultIntersection;
                }
                var details = _getDetails(options) || _createDetails(options, rootNode);
                if (!details.entries.get(domNode)) {
                    details.entries.set(domNode, defaultIntersection);
                    details.observer.observe(domNode);
                }
                return details.entries.get(domNode) || defaultIntersection;
            }
        };
    });
    exports.default = exports.intersection;
});
//# sourceMappingURL=intersection.js.map