var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import WidgetBase from '../WidgetBase';
import { renderer, w } from './../vdom';
import { alwaysRender } from '../decorators/alwaysRender';
export var ProjectorAttachState;
(function (ProjectorAttachState) {
    ProjectorAttachState[ProjectorAttachState["Attached"] = 1] = "Attached";
    ProjectorAttachState[ProjectorAttachState["Detached"] = 2] = "Detached";
})(ProjectorAttachState || (ProjectorAttachState = {}));
let ProjectorWidget = class ProjectorWidget extends WidgetBase {
    render() {
        return this.properties.renderer();
    }
};
ProjectorWidget = __decorate([
    alwaysRender()
], ProjectorWidget);
export function ProjectorMixin(Base) {
    class Projector {
        constructor() {
            this._root = document.body;
            this._async = true;
            this._properties = {};
            this._widget = Base;
        }
        append(root = this._root) {
            this._root = root;
            this._renderResult = w(ProjectorWidget, {
                renderer: () => {
                    const _a = this._properties, { registry } = _a, props = __rest(_a, ["registry"]);
                    return w(this._widget, props, this._children);
                }
            });
            this._renderer = renderer(() => this._renderResult);
            this._renderer.mount({
                domNode: root,
                registry: this._properties.registry,
                sync: !this.async
            });
            this.projectorState = ProjectorAttachState.Attached;
            return {
                destroy() { }
            };
        }
        merge(root = document.body) {
            return this.append(root.parentNode || undefined);
        }
        set root(root) {
            if (this.projectorState === ProjectorAttachState.Attached) {
                throw new Error('Projector already attached, cannot change root element');
            }
            this._root = root;
        }
        get root() {
            return this._root;
        }
        get async() {
            return this._async;
        }
        set async(async) {
            if (this.projectorState === ProjectorAttachState.Attached) {
                throw new Error('Projector already attached, cannot change async mode');
            }
            this._async = async;
        }
        sandbox(doc = document) {
            if (this.projectorState === ProjectorAttachState.Attached) {
                throw new Error('Projector already attached, cannot create sandbox');
            }
            this._async = false;
            this.append(doc.createDocumentFragment());
        }
        setChildren(children) {
            this._children = children;
            if (this._renderer) {
                this._renderer.invalidate();
            }
        }
        setProperties(properties) {
            this._properties = properties;
            if (this._renderer) {
                this._renderer.invalidate();
            }
        }
        toHtml() {
            if (this.projectorState !== ProjectorAttachState.Attached) {
                throw new Error('Projector is not attached, cannot return an HTML string of projection.');
            }
            return this._root.childNodes[0].outerHTML;
        }
        destroy() { }
    }
    return Projector;
}
export default ProjectorMixin;
//# sourceMappingURL=Projector.mjs.map