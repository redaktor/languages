var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import Registry from './Registry';
import { WidgetBase } from './WidgetBase';
import { renderer, w, dom, isTextNode } from './vdom';
import { from } from '../shim/array';
import global from '../shim/global';
import { registerThemeInjector } from './mixins/Themed';
import { alwaysRender } from './decorators/alwaysRender';
const RESERVED_PROPS = ['focus'];
export var CustomElementChildType;
(function (CustomElementChildType) {
    CustomElementChildType["DOJO"] = "DOJO";
    CustomElementChildType["NODE"] = "NODE";
    CustomElementChildType["TEXT"] = "TEXT";
})(CustomElementChildType || (CustomElementChildType = {}));
function isElement(item) {
    return item && item.nodeType === 1;
}
function isDojoChild(item) {
    return isElement(item) && item.tagName.indexOf('-') > -1;
}
export function DomToWidgetWrapper(domNode) {
    let DomToWidgetWrapper = class DomToWidgetWrapper extends WidgetBase {
        render() {
            const properties = Object.keys(this.properties).reduce((props, key) => {
                const value = this.properties[key];
                if (key.indexOf('on') === 0 || RESERVED_PROPS.indexOf(key) !== -1) {
                    key = `__${key}`;
                }
                props[key] = value;
                return props;
            }, {});
            return dom({ node: domNode, props: properties, diffType: 'dom' });
        }
        static get domNode() {
            return domNode;
        }
    };
    DomToWidgetWrapper = __decorate([
        alwaysRender()
    ], DomToWidgetWrapper);
    return DomToWidgetWrapper;
}
export function create(descriptor, WidgetConstructor) {
    const { attributes = [], registryFactory = () => new Registry() } = descriptor;
    const attributeMap = {};
    attributes.forEach((propertyName) => {
        const attributeName = propertyName.toLowerCase();
        attributeMap[attributeName] = propertyName;
    });
    return class extends HTMLElement {
        constructor() {
            super(...arguments);
            this._properties = {};
            this._children = [];
            this._eventProperties = {};
            this._propertiesMap = {};
            this._initialised = false;
            this._childType = descriptor.childType;
        }
        connectedCallback() {
            if (this._initialised) {
                return;
            }
            this._waitTillReady();
        }
        _hasBeenParsed() {
            if (document.readyState !== 'loading') {
                return true;
            }
            let element = this;
            while (element) {
                if (element.nextSibling) {
                    return true;
                }
                element = element.parentNode;
            }
            return false;
        }
        _waitTillReady() {
            this._initialised = true;
            if (this._hasBeenParsed()) {
                this._readyCallback();
            }
            else {
                setTimeout(() => {
                    this._waitTillReady();
                }, 100);
            }
        }
        _readyCallback() {
            const domProperties = {};
            const { properties = [], events = [] } = descriptor;
            this._properties = Object.assign({}, this._properties, this._attributesToProperties(attributes));
            [...attributes, ...properties].forEach((propertyName) => {
                const isReservedProp = RESERVED_PROPS.indexOf(propertyName) !== -1;
                const value = this._propertiesMap[propertyName] || !isReservedProp ? this[propertyName] : undefined;
                let filteredPropertyName = propertyName.replace(/^on/, '__');
                if (isReservedProp) {
                    filteredPropertyName = `__${propertyName}`;
                }
                if (value !== undefined) {
                    this._properties[propertyName] = value;
                }
                if (filteredPropertyName !== propertyName) {
                    domProperties[filteredPropertyName] = {
                        get: () => this._getProperty(propertyName),
                        set: (value) => this._setProperty(propertyName, value)
                    };
                }
                if (!isReservedProp) {
                    domProperties[propertyName] = {
                        get: () => this._getProperty(propertyName),
                        set: (value) => this._setProperty(propertyName, value)
                    };
                }
            });
            events.forEach((propertyName) => {
                const eventName = propertyName.replace(/^on/, '').toLowerCase();
                const filteredPropertyName = propertyName.replace(/^on/, '__on');
                domProperties[filteredPropertyName] = {
                    get: () => this._getEventProperty(propertyName),
                    set: (value) => this._setEventProperty(propertyName, value)
                };
                this._eventProperties[propertyName] = undefined;
                this._properties[propertyName] = (...args) => {
                    const eventCallback = this._getEventProperty(propertyName);
                    if (typeof eventCallback === 'function') {
                        eventCallback(...args);
                    }
                    this.dispatchEvent(new CustomEvent(eventName, {
                        bubbles: false,
                        detail: args
                    }));
                };
            });
            Object.defineProperties(this, domProperties);
            const children = from(this.childNodes).filter((childNode) => !isTextNode(childNode) || childNode.data.replace(/^\s+|\s+$/g, ''));
            if (!this._childType) {
                if (children.some((child) => isDojoChild(child))) {
                    this._childType = CustomElementChildType.DOJO;
                }
                else {
                    this._childType = CustomElementChildType.NODE;
                }
            }
            from(children).forEach((childNode) => {
                if (this._childType === CustomElementChildType.DOJO) {
                    childNode.addEventListener('dojo-ce-render', () => this._render());
                    childNode.addEventListener('dojo-ce-connected', () => this._render());
                    this._children.push(DomToWidgetWrapper(childNode));
                }
                else {
                    this._children.push(dom({ node: childNode, diffType: 'dom' }));
                }
            });
            this.addEventListener('dojo-ce-connected', (e) => this._childConnected(e));
            const widgetProperties = this._properties;
            const renderChildren = () => this.__children__();
            const Wrapper = class extends WidgetBase {
                render() {
                    return w(WidgetConstructor, widgetProperties, renderChildren());
                }
            };
            const registry = registryFactory();
            const themeContext = registerThemeInjector(this._getTheme(), registry);
            global.addEventListener('dojo-theme-set', () => themeContext.set(this._getTheme()));
            const r = renderer(() => w(Wrapper, {}));
            this._renderer = r;
            r.mount({ domNode: this, merge: false, registry });
            const root = this.children[0];
            if (root) {
                const { display = 'block' } = global.getComputedStyle(root);
                this.style.display = display;
            }
            this.dispatchEvent(new CustomEvent('dojo-ce-connected', {
                bubbles: true,
                detail: this
            }));
        }
        _getTheme() {
            if (global && global.dojoce && global.dojoce.theme) {
                return global.dojoce.themes[global.dojoce.theme];
            }
        }
        _childConnected(e) {
            const node = e.detail;
            if (node.parentNode === this) {
                const exists = this._children.some((child) => child.domNode === node);
                if (!exists) {
                    node.addEventListener('dojo-ce-render', () => this._render());
                    this._children.push(DomToWidgetWrapper(node));
                    this._render();
                }
            }
        }
        _render() {
            if (this._renderer) {
                this._renderer.invalidate();
                this.dispatchEvent(new CustomEvent('dojo-ce-render', {
                    bubbles: false,
                    detail: this
                }));
            }
        }
        __properties__() {
            return Object.assign({}, this._properties, this._eventProperties);
        }
        __children__() {
            if (this._childType === CustomElementChildType.DOJO) {
                return this._children.filter((Child) => Child.domNode.isWidget).map((Child) => {
                    const { domNode } = Child;
                    return w(Child, Object.assign({}, domNode.__properties__()), [...domNode.__children__()]);
                });
            }
            else {
                return this._children;
            }
        }
        attributeChangedCallback(name, oldValue, value) {
            const propertyName = attributeMap[name];
            this._setProperty(propertyName, value);
        }
        _setEventProperty(propertyName, value) {
            this._eventProperties[propertyName] = value;
        }
        _getEventProperty(propertyName) {
            return this._eventProperties[propertyName];
        }
        _setProperty(propertyName, value) {
            this._properties[propertyName] = value;
            this._render();
        }
        _getProperty(propertyName) {
            return this._properties[propertyName];
        }
        _attributesToProperties(attributes) {
            return attributes.reduce((properties, propertyName) => {
                const attributeName = propertyName.toLowerCase();
                const value = this.getAttribute(attributeName);
                if (value !== null) {
                    properties[propertyName] = value;
                }
                return properties;
            }, {});
        }
        static get observedAttributes() {
            return Object.keys(attributeMap);
        }
        get isWidget() {
            return true;
        }
        set(key, value) {
            this._propertiesMap[key] = value;
            if (this._renderer) {
                this._setProperty(key, value);
            }
        }
    };
}
export function register(WidgetConstructor) {
    const descriptor = WidgetConstructor.__customElementDescriptor;
    if (!descriptor) {
        throw new Error('Cannot get descriptor for Custom Element, have you added the @customElement decorator to your Widget?');
    }
    global.customElements.define(descriptor.tagName, create(descriptor, WidgetConstructor));
}
export default register;
//# sourceMappingURL=registerCustomElement.mjs.map