{"version":3,"file":"util.mjs","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":"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","sourcesContent":["import { Handle } from './Destroyable';\nimport { DNode, RenderResult } from './interfaces';\nimport { isWNode, isVNode } from './vdom';\n\nconst slice = Array.prototype.slice;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport interface Modifier<T extends DNode> {\n\t(dNode: T, breaker: () => void): void;\n}\n\nexport interface Predicate<T extends DNode> {\n\t(dNode: DNode): dNode is T;\n}\n\nexport interface DecorateOptions<T extends DNode> {\n\tmodifier: Modifier<T>;\n\tpredicate?: Predicate<T>;\n\tshallow?: boolean;\n}\n\n/**\n * Type guard that ensures that the value can be coerced to Object\n * to weed out host objects that do not derive from Object.\n * This function is used to check if we want to deep copy an object or not.\n * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n * so it is not handled here.\n * @param  value The value to check\n * @return       If the value is coercible into an Object\n */\nfunction shouldDeepCopyObject(value: any): value is Object {\n\treturn Object.prototype.toString.call(value) === '[object Object]';\n}\n\nfunction copyArray<T>(array: T[], inherited: boolean): T[] {\n\treturn array.map(function(item: T): T {\n\t\tif (Array.isArray(item)) {\n\t\t\treturn copyArray(item, inherited) as any;\n\t\t}\n\n\t\treturn !shouldDeepCopyObject(item)\n\t\t\t? item\n\t\t\t: _mixin({\n\t\t\t\t\tdeep: true,\n\t\t\t\t\tinherited: inherited,\n\t\t\t\t\tsources: <Array<T>>[item],\n\t\t\t\t\ttarget: <T>{}\n\t\t\t  });\n\t});\n}\n\ninterface MixinArgs<T extends {}, U extends {}> {\n\tdeep: boolean;\n\tinherited: boolean;\n\tsources: (U | null | undefined)[];\n\ttarget: T;\n\tcopied?: any[];\n}\n\nfunction _mixin<T extends {}, U extends {}>(kwArgs: MixinArgs<T, U>): T & U {\n\tconst deep = kwArgs.deep;\n\tconst inherited = kwArgs.inherited;\n\tconst target: any = kwArgs.target;\n\tconst copied = kwArgs.copied || [];\n\tconst copiedClone = [...copied];\n\n\tfor (let i = 0; i < kwArgs.sources.length; i++) {\n\t\tconst source = kwArgs.sources[i];\n\n\t\tif (source === null || source === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (let key in source) {\n\t\t\tif (inherited || hasOwnProperty.call(source, key)) {\n\t\t\t\tlet value: any = source[key];\n\n\t\t\t\tif (copiedClone.indexOf(value) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (deep) {\n\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\tvalue = copyArray(value, inherited);\n\t\t\t\t\t} else if (shouldDeepCopyObject(value)) {\n\t\t\t\t\t\tconst targetValue: any = target[key] || {};\n\t\t\t\t\t\tcopied.push(source);\n\t\t\t\t\t\tvalue = _mixin({\n\t\t\t\t\t\t\tdeep: true,\n\t\t\t\t\t\t\tinherited: inherited,\n\t\t\t\t\t\t\tsources: [value],\n\t\t\t\t\t\t\ttarget: targetValue,\n\t\t\t\t\t\t\tcopied\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttarget[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn <T & U>target;\n}\n\n/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object,\n * recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n * @return The modified target object\n */\nexport function deepAssign<\n\tT extends {},\n\tU extends {},\n\tV extends {},\n\tW extends {},\n\tX extends {},\n\tY extends {},\n\tZ extends {}\n>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X,\n\tsource5: Y\n): T & U & V & W & X & Y;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X\n): T & U & V & W & X;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W\n): T & U & V & W;\nexport function deepAssign<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function deepAssign<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function deepAssign(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: true,\n\t\tinherited: false,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object, recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable properties will be copied to the target object\n * @return The modified target object\n */\nexport function deepMixin<\n\tT extends {},\n\tU extends {},\n\tV extends {},\n\tW extends {},\n\tX extends {},\n\tY extends {},\n\tZ extends {}\n>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X,\n\tsource5: Y\n): T & U & V & W & X & Y;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X\n): T & U & V & W & X;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W\n): T & U & V & W;\nexport function deepMixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMixin<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function deepMixin(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: true,\n\t\tinherited: true,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object.\n *\n * @return The modified target object\n */\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X,\n\tsource5: Y,\n\tsource6: Z\n): T & U & V & W & X & Y & Z;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X,\n\tsource5: Y\n): T & U & V & W & X & Y;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X\n): T & U & V & W & X;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W\n): T & U & V & W;\nexport function mixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function mixin<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function mixin(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: false,\n\t\tinherited: true,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n * Like `Function.prototype.bind`, but does not alter execution context.\n *\n * @param targetFunction The function that needs to be bound\n * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n * @return The bound function\n */\nexport function partial(targetFunction: (...args: any[]) => any, ...suppliedArgs: any[]): (...args: any[]) => any {\n\treturn function(this: any) {\n\t\tconst args: any[] = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\n\t\treturn targetFunction.apply(this, args);\n\t};\n}\n\nexport function guaranteeMinimumTimeout(callback: (...args: any[]) => void, delay?: number): Handle {\n\tconst startTime = Date.now();\n\tlet timerId: any;\n\n\tfunction timeoutHandler() {\n\t\tconst delta = Date.now() - startTime;\n\t\tif (delay == null || delta >= delay) {\n\t\t\tcallback();\n\t\t} else {\n\t\t\ttimerId = setTimeout(timeoutHandler, delay - delta);\n\t\t}\n\t}\n\ttimerId = setTimeout(timeoutHandler, delay);\n\treturn {\n\t\tdestroy: () => {\n\t\t\tif (timerId != null) {\n\t\t\t\tclearTimeout(timerId);\n\t\t\t\ttimerId = null;\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport function debounce<T extends (this: any, ...args: any[]) => void>(callback: T, delay: number): T {\n\tlet timer: Handle | null;\n\n\treturn <T>function() {\n\t\ttimer && timer.destroy();\n\n\t\tlet context = this;\n\t\tlet args: any | null = arguments;\n\n\t\ttimer = guaranteeMinimumTimeout(function() {\n\t\t\tcallback.apply(context, args);\n\t\t\targs = context = timer = null;\n\t\t}, delay);\n\t};\n}\n\nexport function throttle<T extends (this: any, ...args: any[]) => void>(callback: T, delay: number): T {\n\tlet ran: boolean | null;\n\n\treturn <T>function() {\n\t\tif (ran) {\n\t\t\treturn;\n\t\t}\n\n\t\tran = true;\n\t\tlet args: any | null = arguments;\n\n\t\tcallback.apply(this, args);\n\t\tguaranteeMinimumTimeout(function() {\n\t\t\tran = null;\n\t\t}, delay);\n\t};\n}\n\nexport function uuid(): string {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tconst r = (Math.random() * 16) | 0,\n\t\t\tv = c === 'x' ? r : (r & 0x3) | 0x8;\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Generic decorate function for DNodes. The nodes are modified in place based on the provided predicate\n * and modifier functions.\n *\n * The children of each node are flattened and added to the array for decoration.\n *\n * If no predicate is supplied then the modifier will be executed on all nodes. A `breaker` function is passed to the\n * modifier which will drain the nodes array and exit the decoration.\n *\n * When the `shallow` options is set to `true` the only the top node or nodes will be decorated (only supported using\n * `DecorateOptions`).\n */\nexport function decorate<T extends DNode>(dNodes: DNode, options: DecorateOptions<T>): DNode;\nexport function decorate<T extends DNode>(dNodes: DNode[], options: DecorateOptions<T>): DNode[];\nexport function decorate<T extends DNode>(dNodes: DNode | DNode[], options: DecorateOptions<T>): DNode | DNode[];\nexport function decorate<T extends DNode>(dNodes: DNode, modifier: Modifier<T>, predicate: Predicate<T>): DNode;\nexport function decorate<T extends DNode>(dNodes: DNode[], modifier: Modifier<T>, predicate: Predicate<T>): DNode[];\nexport function decorate<T extends DNode>(\n\tdNodes: RenderResult,\n\tmodifier: Modifier<T>,\n\tpredicate: Predicate<T>\n): RenderResult;\nexport function decorate(dNodes: DNode, modifier: Modifier<DNode>): DNode;\nexport function decorate(dNodes: DNode[], modifier: Modifier<DNode>): DNode[];\nexport function decorate(dNodes: RenderResult, modifier: Modifier<DNode>): RenderResult;\nexport function decorate(\n\tdNodes: DNode | DNode[],\n\toptionsOrModifier: Modifier<DNode> | DecorateOptions<DNode>,\n\tpredicate?: Predicate<DNode>\n): DNode | DNode[] {\n\tlet shallow = false;\n\tlet modifier;\n\tif (typeof optionsOrModifier === 'function') {\n\t\tmodifier = optionsOrModifier;\n\t} else {\n\t\tmodifier = optionsOrModifier.modifier;\n\t\tpredicate = optionsOrModifier.predicate;\n\t\tshallow = optionsOrModifier.shallow || false;\n\t}\n\n\tlet nodes = Array.isArray(dNodes) ? [...dNodes] : [dNodes];\n\tfunction breaker() {\n\t\tnodes = [];\n\t}\n\twhile (nodes.length) {\n\t\tconst node = nodes.shift();\n\t\tif (node && node !== true) {\n\t\t\tif (!shallow && (isWNode(node) || isVNode(node)) && node.children) {\n\t\t\t\tnodes = [...nodes, ...node.children];\n\t\t\t}\n\t\t\tif (!predicate || predicate(node)) {\n\t\t\t\tmodifier(node, breaker);\n\t\t\t}\n\t\t}\n\t}\n\treturn dNodes;\n}\n"]}