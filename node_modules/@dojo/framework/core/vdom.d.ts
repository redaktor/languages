import WeakMap from '../shim/WeakMap';
import Set from '../shim/Set';
import Map from '../shim/Map';
import { WNode, VNode, DNode, VNodeProperties, TransitionStrategy, DomVNode, LazyDefine, Constructor, RenderResult, WidgetBaseInterface, Callback, MiddlewareMap, WNodeFactory, UnionToIntersection, WidgetProperties, MiddlewareResultFactory, WidgetBaseTypes, RegistryLabel, DeferredVirtualProperties, DomOptions } from './interfaces';
import { Registry } from './Registry';
import RegistryHandler from './RegistryHandler';
import { NodeHandler } from './NodeHandler';
declare global {
    namespace JSX {
        type Element = WNode;
        interface ElementAttributesProperty {
            properties: {};
        }
        interface IntrinsicElements {
            [key: string]: VNodeProperties;
        }
    }
}
export interface BaseNodeWrapper {
    id: string;
    owningId: string;
    node: WNode<any> | VNode;
    domNode?: Node;
    depth: number;
    order: number;
    requiresInsertBefore?: boolean;
    hasPreviousSiblings?: boolean;
    hasParentWNode?: boolean;
    namespace?: string;
    hasAnimations?: boolean;
    parentId: string;
    childDomWrapperId?: string;
}
export interface WNodeWrapper extends BaseNodeWrapper {
    node: WNode<any>;
    instance?: any;
    mergeNodes?: Node[];
    nodeHandlerCalled?: boolean;
    registryItem?: Callback<any, any, RenderResult> | Constructor<any> | null;
    properties: any;
}
export interface WidgetMeta {
    mountNode: HTMLElement;
    dirty: boolean;
    invalidator: () => void;
    middleware?: any;
    middlewareIds: string[];
    registryHandler?: RegistryHandler;
    registry: Registry;
    properties: any;
    children?: DNode[];
    rendering: boolean;
    nodeMap?: Map<string | number, HTMLElement>;
    destroyMap?: Map<string, () => void>;
    deferRefs: number;
    customDiffProperties?: Set<string>;
    customDiffMap?: Map<string, Map<string, (current: any, next: any) => void>>;
}
export interface WidgetData {
    onDetach: () => void;
    onAttach: () => void;
    dirty: boolean;
    nodeHandler: NodeHandler;
    invalidate?: Function;
    rendering: boolean;
    inputProperties: any;
    registry: RegistryHandler;
}
export interface VNodeWrapper extends BaseNodeWrapper {
    node: VNode | DomVNode;
    merged?: boolean;
    inserted?: boolean;
    deferredProperties?: VNodeProperties;
}
export declare type DNodeWrapper = VNodeWrapper | WNodeWrapper;
export interface MountOptions {
    sync: boolean;
    merge: boolean;
    transition?: TransitionStrategy;
    domNode: HTMLElement;
    registry: Registry;
}
export interface Renderer {
    invalidate(): void;
    mount(mountOptions?: Partial<MountOptions>): void;
}
export declare function isTextNode(item: any): item is Text;
export declare function isWNode<W extends WidgetBaseTypes = any>(child: any): child is WNode<W>;
export declare function isVNode(child: DNode): child is VNode;
export declare function isDomVNode(child: DNode): child is DomVNode;
export declare function isElementNode(value: any): value is Element;
/**
 * Wrapper function for calls to create a widget.
 */
export declare function w<W extends WidgetBaseTypes>(node: WNode<W>, properties: Partial<W['properties']>, children?: W['children']): WNode<W>;
export declare function w<W extends WidgetBaseTypes>(widgetConstructor: Constructor<W> | RegistryLabel | WNodeFactory<W> | LazyDefine<W>, properties: W['properties'], children?: W['children']): WNode<W>;
/**
 * Wrapper function for calls to create VNodes.
 */
export declare function v(node: VNode, properties: VNodeProperties, children: undefined | DNode[]): VNode;
export declare function v(node: VNode, properties: VNodeProperties): VNode;
export declare function v(tag: string, children: undefined | DNode[]): VNode;
export declare function v<K extends keyof HTMLElementTagNameMap>(tag: K, properties: DeferredVirtualProperties | VNodeProperties<HTMLElementTagNameMap[K]>, children?: DNode[]): VNode;
export declare function v(tag: string, properties: DeferredVirtualProperties | VNodeProperties, children?: DNode[]): VNode;
export declare function v(tag: string): VNode;
/**
 * Create a VNode for an existing DOM Node.
 */
export declare function dom({ node, attrs, props, on, diffType, onAttach }: DomOptions, children?: DNode[]): DomVNode;
export declare const REGISTRY_ITEM = "__registry_item";
export declare class FromRegistry<P> {
    static type: string;
    properties: P;
    name: string | undefined;
}
export declare function fromRegistry<P>(tag: string): Constructor<FromRegistry<P>>;
export declare function tsx(tag: any, properties?: {}, ...children: any[]): DNode;
export declare function propertiesDiff(current: any, next: any, invalidator: () => void, ignoreProperties: string[]): void;
export declare function create<T extends MiddlewareMap, MiddlewareProps = ReturnType<T[keyof T]>['properties']>(middlewares?: T): {
    <ReturnValue>(callback: Callback<WidgetProperties & UnionToIntersection<MiddlewareProps>, T, ReturnValue>): ReturnValue extends RenderResult ? WNodeFactory<{
        properties: WidgetProperties & UnionToIntersection<MiddlewareProps>;
        children: DNode<any>[];
    }> : MiddlewareResultFactory<WidgetProperties & UnionToIntersection<MiddlewareProps>, T, ReturnValue>;
    properties: <Props extends {}>() => <ReturnValue>(callback: Callback<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, T, ReturnValue>) => ReturnValue extends RenderResult ? WNodeFactory<{
        properties: Props & WidgetProperties & UnionToIntersection<MiddlewareProps>;
        children: DNode<any>[];
    }> : MiddlewareResultFactory<WidgetProperties & Props & UnionToIntersection<MiddlewareProps>, T, ReturnValue>;
};
export declare const widgetInstanceMap: WeakMap<WidgetBaseInterface<WidgetProperties, DNode<any>>, WidgetData>;
export declare const invalidator: MiddlewareResultFactory<WidgetProperties, MiddlewareMap<() => {
    api: {};
    properties: {};
}>, () => void>;
export declare const node: MiddlewareResultFactory<WidgetProperties, MiddlewareMap<() => {
    api: {};
    properties: {};
}>, {
    get(key: string | number): HTMLElement | null;
}>;
export declare const diffProperty: MiddlewareResultFactory<WidgetProperties, MiddlewareMap<() => {
    api: {};
    properties: {};
}>, (propertyName: string, diff: (current: any, next: any) => void) => void>;
export declare const destroy: MiddlewareResultFactory<WidgetProperties, MiddlewareMap<() => {
    api: {};
    properties: {};
}>, (destroyFunction: () => void) => void>;
export declare const getRegistry: MiddlewareResultFactory<WidgetProperties, MiddlewareMap<() => {
    api: {};
    properties: {};
}>, () => RegistryHandler | null>;
export declare const defer: MiddlewareResultFactory<WidgetProperties, MiddlewareMap<() => {
    api: {};
    properties: {};
}>, {
    pause(): void;
    resume(): void;
}>;
export declare function renderer(renderer: () => RenderResult): Renderer;
export default renderer;
