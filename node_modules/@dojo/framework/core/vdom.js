(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../shim/global", "../core/has", "../shim/WeakMap", "../shim/Set", "../shim/Map", "./Registry", "./diff", "./RegistryHandler"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var global_1 = require("../shim/global");
    var has_1 = require("../core/has");
    var WeakMap_1 = require("../shim/WeakMap");
    var Set_1 = require("../shim/Set");
    var Map_1 = require("../shim/Map");
    var Registry_1 = require("./Registry");
    var diff_1 = require("./diff");
    var RegistryHandler_1 = require("./RegistryHandler");
    var EMPTY_ARRAY = [];
    var nodeOperations = ['focus', 'blur', 'scrollIntoView', 'click'];
    var NAMESPACE_W3 = 'http://www.w3.org/';
    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';
    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';
    var WNODE = '__WNODE_TYPE';
    var VNODE = '__VNODE_TYPE';
    var DOMVNODE = '__DOMVNODE_TYPE';
    function isTextNode(item) {
        return item && item.nodeType === 3;
    }
    exports.isTextNode = isTextNode;
    function isLazyDefine(item) {
        return Boolean(item && item.label);
    }
    function isWNodeWrapper(child) {
        return child && isWNode(child.node);
    }
    function isVNodeWrapper(child) {
        return !!child && isVNode(child.node);
    }
    function isVirtualWrapper(child) {
        return isVNodeWrapper(child) && child.node.tag === 'virtual';
    }
    function isBodyWrapper(wrapper) {
        return isVNodeWrapper(wrapper) && wrapper.node.tag === 'body';
    }
    function isAttachApplication(value) {
        return !!value.type;
    }
    function isWNode(child) {
        return Boolean(child && child !== true && typeof child !== 'string' && child.type === WNODE);
    }
    exports.isWNode = isWNode;
    function isVNode(child) {
        return Boolean(child && child !== true && typeof child !== 'string' && (child.type === VNODE || child.type === DOMVNODE));
    }
    exports.isVNode = isVNode;
    function isDomVNode(child) {
        return Boolean(child && child !== true && typeof child !== 'string' && child.type === DOMVNODE);
    }
    exports.isDomVNode = isDomVNode;
    function isElementNode(value) {
        return !!value.tagName;
    }
    exports.isElementNode = isElementNode;
    function toTextVNode(data) {
        return {
            tag: '',
            properties: {},
            children: undefined,
            text: "" + data,
            type: VNODE
        };
    }
    function updateAttributes(domNode, previousAttributes, attributes, namespace) {
        var attrNames = Object.keys(attributes);
        var attrCount = attrNames.length;
        for (var i = 0; i < attrCount; i++) {
            var attrName = attrNames[i];
            var attrValue = attributes[attrName];
            var previousAttrValue = previousAttributes[attrName];
            if (attrValue !== previousAttrValue) {
                updateAttribute(domNode, attrName, attrValue, namespace);
            }
        }
    }
    function w(widgetConstructorOrNode, properties, children) {
        if (Registry_1.isWNodeFactory(widgetConstructorOrNode)) {
            return widgetConstructorOrNode(properties, children);
        }
        if (isWNode(widgetConstructorOrNode)) {
            properties = tslib_1.__assign({}, widgetConstructorOrNode.properties, properties);
            children = children ? children : widgetConstructorOrNode.children;
            widgetConstructorOrNode = widgetConstructorOrNode.widgetConstructor;
        }
        return {
            children: children || [],
            widgetConstructor: widgetConstructorOrNode,
            properties: properties,
            type: WNODE
        };
    }
    exports.w = w;
    function v(tag, propertiesOrChildren, children) {
        if (propertiesOrChildren === void 0) { propertiesOrChildren = {}; }
        if (children === void 0) { children = undefined; }
        var properties = propertiesOrChildren;
        var deferredPropertiesCallback;
        if (Array.isArray(propertiesOrChildren)) {
            children = propertiesOrChildren;
            properties = {};
        }
        if (typeof properties === 'function') {
            deferredPropertiesCallback = properties;
            properties = {};
        }
        if (isVNode(tag)) {
            var _a = properties.classes, classes = _a === void 0 ? [] : _a, _b = properties.styles, styles = _b === void 0 ? {} : _b, newProperties = tslib_1.__rest(properties, ["classes", "styles"]);
            var _c = tag.properties, _d = _c.classes, nodeClasses = _d === void 0 ? [] : _d, _e = _c.styles, nodeStyles = _e === void 0 ? {} : _e, nodeProperties = tslib_1.__rest(_c, ["classes", "styles"]);
            nodeClasses = Array.isArray(nodeClasses) ? nodeClasses : [nodeClasses];
            classes = Array.isArray(classes) ? classes : [classes];
            styles = tslib_1.__assign({}, nodeStyles, styles);
            properties = tslib_1.__assign({}, nodeProperties, newProperties, { classes: tslib_1.__spread(nodeClasses, classes), styles: styles });
            children = children ? children : tag.children;
            tag = tag.tag;
        }
        return {
            tag: tag,
            deferredPropertiesCallback: deferredPropertiesCallback,
            children: children,
            properties: properties,
            type: VNODE
        };
    }
    exports.v = v;
    /**
     * Create a VNode for an existing DOM Node.
     */
    function dom(_a, children) {
        var node = _a.node, _b = _a.attrs, attrs = _b === void 0 ? {} : _b, _c = _a.props, props = _c === void 0 ? {} : _c, _d = _a.on, on = _d === void 0 ? {} : _d, _e = _a.diffType, diffType = _e === void 0 ? 'none' : _e, onAttach = _a.onAttach;
        return {
            tag: isElementNode(node) ? node.tagName.toLowerCase() : '',
            properties: props,
            attributes: attrs,
            events: on,
            children: children,
            type: DOMVNODE,
            domNode: node,
            text: isElementNode(node) ? undefined : node.data,
            diffType: diffType,
            onAttach: onAttach
        };
    }
    exports.dom = dom;
    exports.REGISTRY_ITEM = '__registry_item';
    var FromRegistry = /** @class */ (function () {
        function FromRegistry() {
            this.properties = {};
        }
        FromRegistry.type = exports.REGISTRY_ITEM;
        return FromRegistry;
    }());
    exports.FromRegistry = FromRegistry;
    function fromRegistry(tag) {
        var _a;
        return _a = /** @class */ (function (_super) {
                tslib_1.__extends(class_1, _super);
                function class_1() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.properties = {};
                    _this.name = tag;
                    return _this;
                }
                return class_1;
            }(FromRegistry)),
            _a.type = exports.REGISTRY_ITEM,
            _a;
    }
    exports.fromRegistry = fromRegistry;
    function spreadChildren(children, child) {
        if (Array.isArray(child)) {
            return child.reduce(spreadChildren, children);
        }
        else {
            return tslib_1.__spread(children, [child]);
        }
    }
    function tsx(tag, properties) {
        if (properties === void 0) { properties = {}; }
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        children = children.reduce(spreadChildren, []);
        properties = properties === null ? {} : properties;
        if (typeof tag === 'string') {
            return v(tag, properties, children);
        }
        else if (tag.type === 'registry' && properties.__autoRegistryItem) {
            var name_1 = properties.__autoRegistryItem;
            delete properties.__autoRegistryItem;
            return w(name_1, properties, children);
        }
        else if (tag.type === exports.REGISTRY_ITEM) {
            var registryItem = new tag();
            return w(registryItem.name, properties, children);
        }
        else {
            return w(tag, properties, children);
        }
    }
    exports.tsx = tsx;
    function propertiesDiff(current, next, invalidator, ignoreProperties) {
        var propertyNames = tslib_1.__spread(Object.keys(current), Object.keys(next));
        for (var i = 0; i < propertyNames.length; i++) {
            if (ignoreProperties.indexOf(propertyNames[i]) > -1) {
                continue;
            }
            var result = diff_1.auto(current[propertyNames[i]], next[propertyNames[i]]);
            if (result.changed) {
                invalidator();
                break;
            }
            ignoreProperties.push(propertyNames[i]);
        }
    }
    exports.propertiesDiff = propertiesDiff;
    function buildPreviousProperties(domNode, current) {
        var _a = current.node, diffType = _a.diffType, properties = _a.properties, attributes = _a.attributes;
        if (!diffType || diffType === 'vdom') {
            return {
                properties: current.deferredProperties
                    ? tslib_1.__assign({}, current.deferredProperties, current.node.properties) : current.node.properties,
                attributes: current.node.attributes,
                events: current.node.events
            };
        }
        else if (diffType === 'none') {
            return {
                properties: {},
                attributes: current.node.attributes ? {} : undefined,
                events: current.node.events
            };
        }
        var newProperties = {
            properties: {}
        };
        if (attributes) {
            newProperties.attributes = {};
            newProperties.events = current.node.events;
            Object.keys(properties).forEach(function (propName) {
                newProperties.properties[propName] = domNode[propName];
            });
            Object.keys(attributes).forEach(function (attrName) {
                newProperties.attributes[attrName] = domNode.getAttribute(attrName);
            });
            return newProperties;
        }
        newProperties.properties = Object.keys(properties).reduce(function (props, property) {
            props[property] = domNode.getAttribute(property) || domNode[property];
            return props;
        }, {});
        return newProperties;
    }
    function checkDistinguishable(wrappers, index, parentWNodeWrapper) {
        var wrapperToCheck = wrappers[index];
        if (isVNodeWrapper(wrapperToCheck) && !wrapperToCheck.node.tag) {
            return;
        }
        var key = wrapperToCheck.node.properties.key;
        var parentName = 'unknown';
        if (parentWNodeWrapper) {
            var widgetConstructor = parentWNodeWrapper.node.widgetConstructor;
            parentName = widgetConstructor.name || 'unknown';
        }
        if (key === undefined || key === null) {
            for (var i = 0; i < wrappers.length; i++) {
                if (i !== index) {
                    var wrapper = wrappers[i];
                    if (same(wrapper, wrapperToCheck)) {
                        var nodeIdentifier = void 0;
                        if (isWNodeWrapper(wrapper)) {
                            nodeIdentifier = wrapper.node.widgetConstructor.name || 'unknown';
                        }
                        else {
                            nodeIdentifier = wrapper.node.tag;
                        }
                        console.warn("A widget (" + parentName + ") has had a child added or removed, but they were not able to uniquely identified. It is recommended to provide a unique 'key' property when using the same widget or element (" + nodeIdentifier + ") multiple times as siblings");
                        break;
                    }
                }
            }
        }
    }
    function same(dnode1, dnode2) {
        if (isVNodeWrapper(dnode1) && isVNodeWrapper(dnode2)) {
            if (isDomVNode(dnode1.node) && isDomVNode(dnode2.node)) {
                if (dnode1.node.domNode !== dnode2.node.domNode) {
                    return false;
                }
            }
            if (dnode1.node.tag !== dnode2.node.tag) {
                return false;
            }
            if (dnode1.node.properties.key !== dnode2.node.properties.key) {
                return false;
            }
            return true;
        }
        else if (isWNodeWrapper(dnode1) && isWNodeWrapper(dnode2)) {
            var widgetConstructor1 = dnode1.registryItem || dnode1.node.widgetConstructor;
            var widgetConstructor2 = dnode2.registryItem || dnode2.node.widgetConstructor;
            if (dnode1.instance === undefined && typeof widgetConstructor2 === 'string') {
                return false;
            }
            if (widgetConstructor1 !== widgetConstructor2) {
                return false;
            }
            if (dnode1.node.properties.key !== dnode2.node.properties.key) {
                return false;
            }
            return true;
        }
        return false;
    }
    function findIndexOfChild(children, sameAs, start) {
        for (var i = start; i < children.length; i++) {
            if (same(children[i], sameAs)) {
                return i;
            }
        }
        return -1;
    }
    function createClassPropValue(classes) {
        if (classes === void 0) { classes = []; }
        var classNames = '';
        if (Array.isArray(classes)) {
            for (var i = 0; i < classes.length; i++) {
                var className = classes[i];
                if (className && className !== true) {
                    classNames = classNames ? classNames + " " + className : className;
                }
            }
            return classNames;
        }
        if (classes && classes !== true) {
            classNames = classes;
        }
        return classNames;
    }
    function updateAttribute(domNode, attrName, attrValue, namespace) {
        if (namespace === NAMESPACE_SVG && attrName === 'href' && attrValue) {
            domNode.setAttributeNS(NAMESPACE_XLINK, attrName, attrValue);
        }
        else if ((attrName === 'role' && attrValue === '') || attrValue === undefined) {
            domNode.removeAttribute(attrName);
        }
        else {
            domNode.setAttribute(attrName, attrValue);
        }
    }
    function arrayFrom(arr) {
        return Array.prototype.slice.call(arr);
    }
    function createFactory(callback, middlewares) {
        var factory = function (properties, children) {
            if (properties) {
                var result = w(callback, properties, children);
                callback.isWidget = true;
                callback.middlewares = middlewares;
                return result;
            }
            return {
                middlewares: middlewares,
                callback: callback
            };
        };
        factory.isFactory = true;
        return factory;
    }
    function create(middlewares) {
        if (middlewares === void 0) { middlewares = {}; }
        function properties() {
            function returns(callback) {
                return createFactory(callback, middlewares);
            }
            return returns;
        }
        function returns(callback) {
            return createFactory(callback, middlewares);
        }
        returns.properties = properties;
        return returns;
    }
    exports.create = create;
    var factory = create();
    function wrapNodes(renderer) {
        var result = renderer();
        var isWNodeWrapper = isWNode(result);
        var callback = function () {
            return result;
        };
        callback.isWNodeWrapper = isWNodeWrapper;
        return factory(callback);
    }
    exports.widgetInstanceMap = new WeakMap_1.default();
    var widgetMetaMap = new Map_1.default();
    var requestedDomNodes = new Set_1.default();
    var wrapperId = 0;
    var metaId = 0;
    function addNodeToMap(id, key, node) {
        var widgetMeta = widgetMetaMap.get(id);
        if (widgetMeta) {
            widgetMeta.nodeMap = widgetMeta.nodeMap || new Map_1.default();
            widgetMeta.nodeMap.set(key, node);
            if (requestedDomNodes.has(id + "-" + key)) {
                widgetMeta.invalidator();
                requestedDomNodes.delete(id + "-" + key);
            }
        }
    }
    function destroyHandles(meta) {
        var destroyMap = meta.destroyMap, middlewareIds = meta.middlewareIds;
        if (!destroyMap) {
            return;
        }
        for (var i = 0; i < middlewareIds.length; i++) {
            var id = middlewareIds[i];
            var destroy_1 = destroyMap.get(id);
            destroy_1 && destroy_1();
            destroyMap.delete(id);
            if (destroyMap.size === 0) {
                break;
            }
        }
        destroyMap.clear();
    }
    function runDiffs(meta, current, next) {
        meta.customDiffMap = meta.customDiffMap || new Map_1.default();
        if (meta.customDiffMap.size) {
            meta.customDiffMap.forEach(function (diffMap) {
                diffMap.forEach(function (diff) { return diff(tslib_1.__assign({}, current), tslib_1.__assign({}, next)); });
            });
        }
    }
    exports.invalidator = factory(function (_a) {
        var id = _a.id;
        var _b = tslib_1.__read(id.split('-'), 1), widgetId = _b[0];
        return function () {
            var widgetMeta = widgetMetaMap.get(widgetId);
            if (widgetMeta) {
                return widgetMeta.invalidator();
            }
        };
    });
    exports.node = factory(function (_a) {
        var id = _a.id;
        return {
            get: function (key) {
                var _a = tslib_1.__read(id.split('-'), 1), widgetId = _a[0];
                var widgetMeta = widgetMetaMap.get(widgetId);
                if (widgetMeta) {
                    widgetMeta.nodeMap = widgetMeta.nodeMap || new Map_1.default();
                    var mountNode = widgetMeta.mountNode;
                    var node_1 = widgetMeta.nodeMap.get(key);
                    if (node_1 && mountNode.contains(node_1)) {
                        return node_1;
                    }
                    requestedDomNodes.add(widgetId + "-" + key);
                }
                return null;
            }
        };
    });
    exports.diffProperty = factory(function (_a) {
        var id = _a.id;
        return function (propertyName, diff) {
            var _a = tslib_1.__read(id.split('-'), 1), widgetId = _a[0];
            var widgetMeta = widgetMetaMap.get(widgetId);
            if (widgetMeta) {
                widgetMeta.customDiffMap = widgetMeta.customDiffMap || new Map_1.default();
                widgetMeta.customDiffProperties = widgetMeta.customDiffProperties || new Set_1.default();
                var propertyDiffMap = widgetMeta.customDiffMap.get(id) || new Map_1.default();
                if (!propertyDiffMap.has(propertyName)) {
                    propertyDiffMap.set(propertyName, diff);
                    widgetMeta.customDiffProperties.add(propertyName);
                }
                widgetMeta.customDiffMap.set(id, propertyDiffMap);
            }
        };
    });
    exports.destroy = factory(function (_a) {
        var id = _a.id;
        return function (destroyFunction) {
            var _a = tslib_1.__read(id.split('-'), 1), widgetId = _a[0];
            var widgetMeta = widgetMetaMap.get(widgetId);
            if (widgetMeta) {
                widgetMeta.destroyMap = widgetMeta.destroyMap || new Map_1.default();
                if (!widgetMeta.destroyMap.has(id)) {
                    widgetMeta.destroyMap.set(id, destroyFunction);
                }
            }
        };
    });
    exports.getRegistry = factory(function (_a) {
        var id = _a.id;
        var _b = tslib_1.__read(id.split('-'), 1), widgetId = _b[0];
        return function () {
            var widgetMeta = widgetMetaMap.get(widgetId);
            if (widgetMeta) {
                if (!widgetMeta.registryHandler) {
                    widgetMeta.registryHandler = new RegistryHandler_1.default();
                    widgetMeta.registryHandler.base = widgetMeta.registry;
                    widgetMeta.registryHandler.on('invalidate', widgetMeta.invalidator);
                }
                widgetMeta.registryHandler = widgetMeta.registryHandler || new RegistryHandler_1.default();
                return widgetMeta.registryHandler;
            }
            return null;
        };
    });
    exports.defer = factory(function (_a) {
        var id = _a.id;
        var _b = tslib_1.__read(id.split('-'), 1), widgetId = _b[0];
        var isDeferred = false;
        return {
            pause: function () {
                var widgetMeta = widgetMetaMap.get(widgetId);
                if (!isDeferred && widgetMeta) {
                    widgetMeta.deferRefs = widgetMeta.deferRefs + 1;
                    isDeferred = true;
                }
            },
            resume: function () {
                var widgetMeta = widgetMetaMap.get(widgetId);
                if (isDeferred && widgetMeta) {
                    widgetMeta.deferRefs = widgetMeta.deferRefs - 1;
                    isDeferred = false;
                }
            }
        };
    });
    function renderer(renderer) {
        var _mountOptions = {
            sync: false,
            merge: true,
            transition: undefined,
            domNode: global_1.default.document.body,
            registry: new Registry_1.Registry()
        };
        var _invalidationQueue = [];
        var _processQueue = [];
        var _deferredProcessQueue = [];
        var _applicationQueue = [];
        var _eventMap = new WeakMap_1.default();
        var _idToWrapperMap = new Map_1.default();
        var _wrapperSiblingMap = new WeakMap_1.default();
        var _idToChildrenWrappers = new Map_1.default();
        var _insertBeforeMap = new WeakMap_1.default();
        var _nodeToWrapperMap = new WeakMap_1.default();
        var _renderScheduled;
        var _idleCallbacks = [];
        var _deferredRenderCallbacks = [];
        var parentInvalidate;
        var _allMergedNodes = [];
        function nodeOperation(propName, propValue, previousValue, domNode) {
            var result = propValue && !previousValue;
            if (typeof propValue === 'function') {
                result = propValue();
            }
            if (result === true) {
                _deferredRenderCallbacks.push(function () {
                    domNode[propName]();
                });
            }
        }
        function updateEvent(domNode, eventName, currentValue, previousValue) {
            if (previousValue) {
                var previousEvent = _eventMap.get(previousValue);
                previousEvent && domNode.removeEventListener(eventName, previousEvent);
            }
            var callback = currentValue;
            if (eventName === 'input') {
                callback = function (evt) {
                    currentValue.call(this, evt);
                    evt.target['oninput-value'] = evt.target.value;
                };
            }
            domNode.addEventListener(eventName, callback);
            _eventMap.set(currentValue, callback);
        }
        function removeOrphanedEvents(domNode, previousProperties, properties, onlyEvents) {
            if (onlyEvents === void 0) { onlyEvents = false; }
            Object.keys(previousProperties).forEach(function (propName) {
                var isEvent = propName.substr(0, 2) === 'on' || onlyEvents;
                var eventName = onlyEvents ? propName : propName.substr(2);
                if (isEvent && !properties[propName]) {
                    var eventCallback = _eventMap.get(previousProperties[propName]);
                    if (eventCallback) {
                        domNode.removeEventListener(eventName, eventCallback);
                    }
                }
            });
        }
        function resolveRegistryItem(wrapper, instance, id) {
            if (!Registry_1.isWidget(wrapper.node.widgetConstructor)) {
                var owningNode = _nodeToWrapperMap.get(wrapper.node);
                if (owningNode) {
                    if (owningNode.instance) {
                        instance = owningNode.instance;
                    }
                    else {
                        id = owningNode.id;
                    }
                }
                var registry = void 0;
                if (instance) {
                    var instanceData = exports.widgetInstanceMap.get(instance);
                    if (instanceData) {
                        registry = instanceData.registry;
                    }
                }
                else if (id !== undefined) {
                    var widgetMeta = widgetMetaMap.get(id);
                    if (widgetMeta) {
                        if (!widgetMeta.registryHandler) {
                            widgetMeta.registryHandler = new RegistryHandler_1.default();
                            widgetMeta.registryHandler.base = widgetMeta.registry;
                            widgetMeta.registryHandler.on('invalidate', widgetMeta.invalidator);
                        }
                        registry = widgetMeta.registryHandler;
                    }
                }
                if (registry) {
                    var registryLabel = void 0;
                    if (isLazyDefine(wrapper.node.widgetConstructor)) {
                        var _a = wrapper.node.widgetConstructor, label = _a.label, registryItem = _a.registryItem;
                        if (!registry.has(label)) {
                            registry.define(label, registryItem);
                        }
                        registryLabel = label;
                    }
                    else {
                        registryLabel = wrapper.node.widgetConstructor;
                    }
                    var item = registry.get(registryLabel);
                    if (Registry_1.isWNodeFactory(item)) {
                        var node_2 = item(wrapper.node.properties, wrapper.node.children);
                        if (Registry_1.isWidgetFunction(node_2.widgetConstructor)) {
                            wrapper.registryItem = node_2.widgetConstructor;
                        }
                    }
                    else {
                        wrapper.registryItem = item;
                    }
                }
            }
        }
        function mapNodeToInstance(nodes, wrapper) {
            while (nodes.length) {
                var node_3 = nodes.pop();
                if (isWNode(node_3) || isVNode(node_3)) {
                    if (!_nodeToWrapperMap.has(node_3)) {
                        _nodeToWrapperMap.set(node_3, wrapper);
                        if (node_3.children && node_3.children.length) {
                            nodes = tslib_1.__spread(nodes, node_3.children);
                        }
                    }
                }
            }
        }
        function renderedToWrapper(rendered, parent, currentParent) {
            var requiresInsertBefore = parent.requiresInsertBefore, hasPreviousSiblings = parent.hasPreviousSiblings, namespace = parent.namespace, depth = parent.depth;
            var wrappedRendered = [];
            var hasParentWNode = isWNodeWrapper(parent);
            var hasVirtualParentNode = isVirtualWrapper(parent);
            var currentParentChildren = (isVNodeWrapper(currentParent) && _idToChildrenWrappers.get(currentParent.id)) || [];
            var hasCurrentParentChildren = currentParentChildren.length > 0;
            var insertBefore = ((requiresInsertBefore || hasPreviousSiblings !== false) && (hasParentWNode || hasVirtualParentNode)) ||
                (hasCurrentParentChildren && rendered.length > 1);
            var previousItem;
            if (isWNodeWrapper(parent) && rendered.length) {
                mapNodeToInstance(tslib_1.__spread(rendered), parent);
            }
            for (var i = 0; i < rendered.length; i++) {
                var renderedItem = rendered[i];
                if (!renderedItem || renderedItem === true) {
                    continue;
                }
                if (typeof renderedItem === 'string') {
                    renderedItem = toTextVNode(renderedItem);
                }
                var owningNode = _nodeToWrapperMap.get(renderedItem);
                var wrapper = {
                    node: renderedItem,
                    depth: depth + 1,
                    order: i,
                    parentId: parent.id,
                    requiresInsertBefore: insertBefore,
                    hasParentWNode: hasParentWNode,
                    namespace: namespace
                };
                if (isVNode(renderedItem)) {
                    if (renderedItem.deferredPropertiesCallback) {
                        wrapper.deferredProperties = renderedItem.deferredPropertiesCallback(false);
                    }
                    if (renderedItem.properties.exitAnimation) {
                        parent.hasAnimations = true;
                        var nextParent = _idToWrapperMap.get(parent.parentId);
                        while (nextParent) {
                            if (nextParent.hasAnimations) {
                                break;
                            }
                            nextParent.hasAnimations = true;
                            nextParent = _idToWrapperMap.get(nextParent.parentId);
                        }
                    }
                }
                if (owningNode) {
                    wrapper.owningId = owningNode.id;
                }
                if (isWNode(renderedItem)) {
                    resolveRegistryItem(wrapper, parent.instance, parent.id);
                }
                if (previousItem) {
                    _wrapperSiblingMap.set(previousItem, wrapper);
                }
                wrappedRendered.push(wrapper);
                previousItem = wrapper;
            }
            return wrappedRendered;
        }
        function findParentDomNode(currentNode) {
            var parentDomNode;
            var parentWrapper = _idToWrapperMap.get(currentNode.parentId);
            while (!parentDomNode && parentWrapper) {
                if (!parentDomNode &&
                    isVNodeWrapper(parentWrapper) &&
                    !isVirtualWrapper(parentWrapper) &&
                    parentWrapper.domNode) {
                    parentDomNode = parentWrapper.domNode;
                }
                parentWrapper = _idToWrapperMap.get(parentWrapper.parentId);
            }
            return parentDomNode;
        }
        function runDeferredProperties(next) {
            var deferredPropertiesCallback = next.node.deferredPropertiesCallback;
            if (deferredPropertiesCallback) {
                var properties_1 = next.node.properties;
                _deferredRenderCallbacks.push(function () {
                    if (_idToWrapperMap.has(next.owningId)) {
                        var deferredProperties = next.deferredProperties;
                        next.deferredProperties = deferredPropertiesCallback(true);
                        processProperties(next, {
                            properties: tslib_1.__assign({}, deferredProperties, properties_1)
                        });
                    }
                });
            }
        }
        function findInsertBefore(next) {
            var insertBefore = null;
            var searchNode = next;
            while (!insertBefore) {
                var nextSibling = _wrapperSiblingMap.get(searchNode);
                if (nextSibling) {
                    var domNode = nextSibling.domNode;
                    if ((isWNodeWrapper(nextSibling) || isVirtualWrapper(nextSibling)) && nextSibling.childDomWrapperId) {
                        var childWrapper = _idToWrapperMap.get(nextSibling.childDomWrapperId);
                        if (childWrapper) {
                            domNode = childWrapper.domNode;
                        }
                    }
                    if (domNode && domNode.parentNode) {
                        insertBefore = domNode;
                        break;
                    }
                    searchNode = nextSibling;
                    continue;
                }
                searchNode = searchNode && _idToWrapperMap.get(searchNode.parentId);
                if (!searchNode || (isVNodeWrapper(searchNode) && !isVirtualWrapper(searchNode))) {
                    break;
                }
            }
            return insertBefore;
        }
        function setValue(domNode, propValue, previousValue) {
            var domValue = domNode.value;
            var onInputValue = domNode['oninput-value'];
            var onSelectValue = domNode['select-value'];
            if (onSelectValue && domValue !== onSelectValue) {
                domNode.value = onSelectValue;
                if (domNode.value === onSelectValue) {
                    domNode['select-value'] = undefined;
                }
            }
            else if ((onInputValue && domValue === onInputValue) || propValue !== previousValue) {
                domNode.value = propValue;
                domNode['oninput-value'] = undefined;
            }
        }
        function setProperties(domNode, currentProperties, nextWrapper, includesEventsAndAttributes) {
            if (currentProperties === void 0) { currentProperties = {}; }
            if (includesEventsAndAttributes === void 0) { includesEventsAndAttributes = true; }
            var properties = nextWrapper.deferredProperties
                ? tslib_1.__assign({}, nextWrapper.deferredProperties, nextWrapper.node.properties) : nextWrapper.node.properties;
            var propNames = Object.keys(properties);
            var propCount = propNames.length;
            if (propNames.indexOf('classes') === -1 && currentProperties.classes) {
                domNode.removeAttribute('class');
            }
            includesEventsAndAttributes && removeOrphanedEvents(domNode, currentProperties, properties);
            for (var i = 0; i < propCount; i++) {
                var propName = propNames[i];
                var propValue = properties[propName];
                var previousValue = currentProperties[propName];
                if (propName === 'classes') {
                    var previousClassString = createClassPropValue(previousValue);
                    var currentClassString = createClassPropValue(propValue);
                    if (previousClassString !== currentClassString) {
                        if (currentClassString) {
                            if (nextWrapper.merged) {
                                var domClasses = (domNode.getAttribute('class') || '').split(' ');
                                for (var i_1 = 0; i_1 < domClasses.length; i_1++) {
                                    if (currentClassString.indexOf(domClasses[i_1]) === -1) {
                                        currentClassString = domClasses[i_1] + " " + currentClassString;
                                    }
                                }
                            }
                            domNode.setAttribute('class', currentClassString);
                        }
                        else {
                            domNode.removeAttribute('class');
                        }
                    }
                }
                else if (nodeOperations.indexOf(propName) !== -1) {
                    nodeOperation(propName, propValue, previousValue, domNode);
                }
                else if (propName === 'styles') {
                    var styleNames = Object.keys(propValue);
                    var styleCount = styleNames.length;
                    for (var j = 0; j < styleCount; j++) {
                        var styleName = styleNames[j];
                        var newStyleValue = propValue[styleName];
                        var oldStyleValue = previousValue && previousValue[styleName];
                        if (newStyleValue === oldStyleValue) {
                            continue;
                        }
                        domNode.style[styleName] = newStyleValue || '';
                    }
                }
                else {
                    if (!propValue && typeof previousValue === 'string') {
                        propValue = '';
                    }
                    if (propName === 'value') {
                        if (domNode.tagName === 'SELECT') {
                            domNode['select-value'] = propValue;
                        }
                        setValue(domNode, propValue, previousValue);
                    }
                    else if (propName !== 'key' && propValue !== previousValue) {
                        var type = typeof propValue;
                        if (type === 'function' && propName.lastIndexOf('on', 0) === 0 && includesEventsAndAttributes) {
                            updateEvent(domNode, propName.substr(2), propValue, previousValue);
                        }
                        else if (type === 'string' && propName !== 'innerHTML' && includesEventsAndAttributes) {
                            updateAttribute(domNode, propName, propValue, nextWrapper.namespace);
                        }
                        else if (propName === 'scrollLeft' || propName === 'scrollTop') {
                            if (domNode[propName] !== propValue) {
                                domNode[propName] = propValue;
                            }
                        }
                        else {
                            domNode[propName] = propValue;
                        }
                    }
                }
            }
        }
        function runDeferredRenderCallbacks() {
            var sync = _mountOptions.sync;
            var callbacks = _deferredRenderCallbacks;
            _deferredRenderCallbacks = [];
            if (callbacks.length) {
                var run = function () {
                    var callback;
                    while ((callback = callbacks.shift())) {
                        callback();
                    }
                };
                if (sync) {
                    run();
                }
                else {
                    global_1.default.requestAnimationFrame(run);
                }
            }
        }
        function runAfterRenderCallbacks() {
            var sync = _mountOptions.sync;
            var callbacks = _idleCallbacks;
            _idleCallbacks = [];
            if (callbacks.length) {
                var run = function () {
                    var callback;
                    while ((callback = callbacks.shift())) {
                        callback();
                    }
                };
                if (sync) {
                    run();
                }
                else {
                    if (global_1.default.requestIdleCallback) {
                        global_1.default.requestIdleCallback(run);
                    }
                    else {
                        setTimeout(run);
                    }
                }
            }
        }
        function processProperties(next, previousProperties) {
            if (next.node.attributes && next.node.events) {
                updateAttributes(next.domNode, previousProperties.attributes || {}, next.node.attributes, next.namespace);
                setProperties(next.domNode, previousProperties.properties, next, false);
                var events_1 = next.node.events || {};
                if (previousProperties.events) {
                    removeOrphanedEvents(next.domNode, previousProperties.events || {}, next.node.events, true);
                }
                previousProperties.events = previousProperties.events || {};
                Object.keys(events_1).forEach(function (event) {
                    updateEvent(next.domNode, event, events_1[event], previousProperties.events[event]);
                });
            }
            else {
                setProperties(next.domNode, previousProperties.properties, next);
            }
        }
        function mount(mountOptions) {
            if (mountOptions === void 0) { mountOptions = {}; }
            _mountOptions = tslib_1.__assign({}, _mountOptions, mountOptions);
            var domNode = _mountOptions.domNode;
            var renderResult = wrapNodes(renderer)({});
            var nextWrapper = {
                id: "" + wrapperId++,
                node: renderResult,
                order: 0,
                depth: 1,
                owningId: '-1',
                parentId: '-1',
                siblingId: '-1',
                properties: {}
            };
            _idToWrapperMap.set('-1', {
                id: "-1",
                depth: 0,
                order: 0,
                owningId: '',
                domNode: domNode,
                node: v('fake'),
                parentId: '-1'
            });
            _processQueue.push({
                current: [],
                next: [nextWrapper],
                meta: { mergeNodes: arrayFrom(domNode.childNodes) }
            });
            _runProcessQueue();
            _runDomInstructionQueue();
            _cleanUpMergedNodes();
            _insertBeforeMap = undefined;
            _runCallbacks();
        }
        function invalidate() {
            parentInvalidate && parentInvalidate();
        }
        function _schedule() {
            var sync = _mountOptions.sync;
            if (sync) {
                _runInvalidationQueue();
            }
            else if (!_renderScheduled) {
                _renderScheduled = global_1.default.requestAnimationFrame(function () {
                    _runInvalidationQueue();
                });
            }
        }
        function getWNodeWrapper(id) {
            var wrapper = _idToWrapperMap.get(id);
            if (wrapper && isWNodeWrapper(wrapper)) {
                return wrapper;
            }
        }
        function _runInvalidationQueue() {
            _renderScheduled = undefined;
            var invalidationQueue = tslib_1.__spread(_invalidationQueue);
            var previouslyRendered = [];
            _invalidationQueue = [];
            invalidationQueue.sort(function (a, b) {
                var result = b.depth - a.depth;
                if (result === 0) {
                    result = b.order - a.order;
                }
                return result;
            });
            if (_deferredProcessQueue.length) {
                _processQueue = tslib_1.__spread(_deferredProcessQueue);
                _deferredProcessQueue = [];
                _runProcessQueue();
                if (_deferredProcessQueue.length) {
                    _invalidationQueue = tslib_1.__spread(invalidationQueue);
                    invalidationQueue = [];
                }
            }
            var item;
            while ((item = invalidationQueue.pop())) {
                var id = item.id;
                var current = getWNodeWrapper(id);
                if (!current || previouslyRendered.indexOf(id) !== -1 || !_idToWrapperMap.has(current.parentId)) {
                    continue;
                }
                previouslyRendered.push(id);
                var sibling = _wrapperSiblingMap.get(current);
                var next = {
                    node: {
                        type: WNODE,
                        widgetConstructor: current.node.widgetConstructor,
                        properties: current.properties || {},
                        children: current.node.children || []
                    },
                    instance: current.instance,
                    id: current.id,
                    properties: current.properties,
                    depth: current.depth,
                    order: current.order,
                    owningId: current.owningId,
                    parentId: current.parentId,
                    registryItem: current.registryItem
                };
                sibling && _wrapperSiblingMap.set(next, sibling);
                var result = _updateWidget({ current: current, next: next });
                if (result && result.item) {
                    _processQueue.push(result.item);
                    _idToWrapperMap.set(id, next);
                    _runProcessQueue();
                }
            }
            _runDomInstructionQueue();
            _cleanUpMergedNodes();
            _runCallbacks();
        }
        function _cleanUpMergedNodes() {
            if (_deferredProcessQueue.length === 0) {
                var mergedNode = void 0;
                while ((mergedNode = _allMergedNodes.pop())) {
                    mergedNode.parentNode && mergedNode.parentNode.removeChild(mergedNode);
                }
                _mountOptions.merge = false;
            }
        }
        function _runProcessQueue() {
            var item;
            while ((item = _processQueue.pop())) {
                if (isAttachApplication(item)) {
                    item.type === 'attach' && setDomNodeOnParentWrapper(item.id);
                    if (item.instance) {
                        _applicationQueue.push(item);
                    }
                }
                else {
                    var current = item.current, next = item.next, meta = item.meta;
                    _process(current || EMPTY_ARRAY, next || EMPTY_ARRAY, meta);
                }
            }
        }
        function _runDomInstructionQueue() {
            _applicationQueue.reverse();
            var item;
            while ((item = _applicationQueue.pop())) {
                if (item.type === 'create') {
                    var parentDomNode = item.parentDomNode, next = item.next, _a = item.next, domNode = _a.domNode, merged = _a.merged, requiresInsertBefore = _a.requiresInsertBefore, node_4 = _a.node;
                    processProperties(next, { properties: {} });
                    runDeferredProperties(next);
                    if (!merged) {
                        var insertBefore = void 0;
                        if (requiresInsertBefore) {
                            insertBefore = findInsertBefore(next);
                        }
                        else if (_insertBeforeMap) {
                            insertBefore = _insertBeforeMap.get(next);
                        }
                        parentDomNode.insertBefore(domNode, insertBefore);
                        if (isDomVNode(next.node) && next.node.onAttach) {
                            next.node.onAttach();
                        }
                    }
                    if (domNode.tagName === 'OPTION' && domNode.parentElement) {
                        setValue(domNode.parentElement);
                    }
                    var _b = node_4.properties, enterAnimation = _b.enterAnimation, enterAnimationActive = _b.enterAnimationActive;
                    if (_mountOptions.transition && enterAnimation && enterAnimation !== true) {
                        _mountOptions.transition.enter(domNode, enterAnimation, enterAnimationActive);
                    }
                    var owningWrapper = _nodeToWrapperMap.get(next.node);
                    if (owningWrapper && node_4.properties.key != null) {
                        if (owningWrapper.instance) {
                            var instanceData = exports.widgetInstanceMap.get(owningWrapper.instance);
                            instanceData && instanceData.nodeHandler.add(domNode, "" + node_4.properties.key);
                        }
                        else {
                            addNodeToMap(owningWrapper.id, node_4.properties.key, domNode);
                        }
                    }
                    item.next.inserted = true;
                }
                else if (item.type === 'update') {
                    var next = item.next, domNode = item.next.domNode, current = item.current, currentDomNode = item.current.domNode;
                    if (isTextNode(domNode) && isTextNode(currentDomNode) && domNode !== currentDomNode) {
                        currentDomNode.parentNode && currentDomNode.parentNode.replaceChild(domNode, currentDomNode);
                    }
                    else {
                        var previousProperties = buildPreviousProperties(domNode, current);
                        processProperties(next, previousProperties);
                        runDeferredProperties(next);
                    }
                }
                else if (item.type === 'delete') {
                    var current = item.current;
                    var _c = current.node.properties, exitAnimation = _c.exitAnimation, exitAnimationActive = _c.exitAnimationActive;
                    if (_mountOptions.transition && exitAnimation && exitAnimation !== true) {
                        _mountOptions.transition.exit(current.domNode, exitAnimation, exitAnimationActive);
                    }
                    else {
                        current.domNode.parentNode.removeChild(current.domNode);
                    }
                }
                else if (item.type === 'attach') {
                    var instance = item.instance, attached = item.attached;
                    var instanceData = exports.widgetInstanceMap.get(instance);
                    if (instanceData) {
                        instanceData.nodeHandler.addRoot();
                        attached && instanceData.onAttach();
                    }
                }
                else if (item.type === 'detach') {
                    if (item.current.instance) {
                        var instanceData = exports.widgetInstanceMap.get(item.current.instance);
                        instanceData && instanceData.onDetach();
                    }
                    item.current.instance = undefined;
                }
            }
            if (_deferredProcessQueue.length === 0) {
                _nodeToWrapperMap = new WeakMap_1.default();
            }
        }
        function _runCallbacks() {
            runAfterRenderCallbacks();
            runDeferredRenderCallbacks();
        }
        function _processMergeNodes(next, mergeNodes) {
            var merge = _mountOptions.merge;
            if (merge && mergeNodes.length) {
                if (isVNodeWrapper(next)) {
                    var tag = next.node.tag;
                    for (var i = 0; i < mergeNodes.length; i++) {
                        var domElement = mergeNodes[i];
                        var tagName = domElement.tagName || '';
                        if (tag.toUpperCase() === tagName.toUpperCase()) {
                            var mergeNodeIndex = _allMergedNodes.indexOf(domElement);
                            if (mergeNodeIndex !== -1) {
                                _allMergedNodes.splice(mergeNodeIndex, 1);
                            }
                            mergeNodes.splice(i, 1);
                            next.domNode = domElement;
                            break;
                        }
                    }
                }
                else {
                    next.mergeNodes = mergeNodes;
                }
            }
        }
        function registerDistinguishableCallback(childNodes, index) {
            _idleCallbacks.push(function () {
                var parentWNodeWrapper = getWNodeWrapper(childNodes[index].owningId);
                checkDistinguishable(childNodes, index, parentWNodeWrapper);
            });
        }
        function createKeyMap(wrappers) {
            var keys = [];
            for (var i = 0; i < wrappers.length; i++) {
                var wrapper = wrappers[i];
                if (wrapper.node.properties.key != null) {
                    keys.push(wrapper.node.properties.key);
                }
                else {
                    return false;
                }
            }
            return keys;
        }
        function _process(current, next, meta) {
            if (meta === void 0) { meta = {}; }
            var _a = meta.mergeNodes, mergeNodes = _a === void 0 ? [] : _a, _b = meta.oldIndex, oldIndex = _b === void 0 ? 0 : _b, _c = meta.newIndex, newIndex = _c === void 0 ? 0 : _c;
            var currentLength = current.length;
            var nextLength = next.length;
            var hasPreviousSiblings = currentLength > 1 || (currentLength > 0 && currentLength < nextLength);
            var instructions = [];
            var replace = false;
            if (oldIndex === 0 && newIndex === 0 && currentLength) {
                var currentKeys = createKeyMap(current);
                if (currentKeys) {
                    var nextKeys = createKeyMap(next);
                    if (nextKeys) {
                        for (var i = 0; i < currentKeys.length; i++) {
                            if (nextKeys.indexOf(currentKeys[i]) !== -1) {
                                instructions = [];
                                replace = false;
                                break;
                            }
                            replace = true;
                            instructions.push({ current: current[i], next: undefined });
                        }
                    }
                }
            }
            if (replace || (currentLength === 0 && !_mountOptions.merge)) {
                for (var i = 0; i < next.length; i++) {
                    instructions.push({ current: undefined, next: next[i] });
                }
            }
            else {
                if (newIndex < nextLength) {
                    var currentWrapper = oldIndex < currentLength ? current[oldIndex] : undefined;
                    var nextWrapper = next[newIndex];
                    nextWrapper.hasPreviousSiblings = hasPreviousSiblings;
                    _processMergeNodes(nextWrapper, mergeNodes);
                    if (currentWrapper && same(currentWrapper, nextWrapper)) {
                        oldIndex++;
                        newIndex++;
                        if (isVNodeWrapper(currentWrapper) && isVNodeWrapper(nextWrapper)) {
                            nextWrapper.inserted = currentWrapper.inserted;
                        }
                        instructions.push({ current: currentWrapper, next: nextWrapper });
                    }
                    else if (!currentWrapper || findIndexOfChild(current, nextWrapper, oldIndex + 1) === -1) {
                        has_1.default('dojo-debug') && current.length && registerDistinguishableCallback(next, newIndex);
                        instructions.push({ current: undefined, next: nextWrapper });
                        newIndex++;
                    }
                    else if (findIndexOfChild(next, currentWrapper, newIndex + 1) === -1) {
                        has_1.default('dojo-debug') && registerDistinguishableCallback(current, oldIndex);
                        instructions.push({ current: currentWrapper, next: undefined });
                        oldIndex++;
                    }
                    else {
                        has_1.default('dojo-debug') && registerDistinguishableCallback(next, newIndex);
                        has_1.default('dojo-debug') && registerDistinguishableCallback(current, oldIndex);
                        instructions.push({ current: currentWrapper, next: undefined });
                        instructions.push({ current: undefined, next: nextWrapper });
                        oldIndex++;
                        newIndex++;
                    }
                }
                if (newIndex < nextLength) {
                    _processQueue.push({ current: current, next: next, meta: { mergeNodes: mergeNodes, oldIndex: oldIndex, newIndex: newIndex } });
                }
                if (currentLength > oldIndex && newIndex >= nextLength) {
                    for (var i = oldIndex; i < currentLength; i++) {
                        has_1.default('dojo-debug') && registerDistinguishableCallback(current, i);
                        instructions.push({ current: current[i], next: undefined });
                    }
                }
            }
            for (var i = 0; i < instructions.length; i++) {
                var result = _processOne(instructions[i]);
                if (result === false) {
                    if (_mountOptions.merge && mergeNodes.length) {
                        if (newIndex < nextLength) {
                            _processQueue.pop();
                        }
                        _processQueue.push({ next: next, current: current, meta: meta });
                        _deferredProcessQueue = _processQueue;
                        _processQueue = [];
                        break;
                    }
                    continue;
                }
                var widget = result.widget, item = result.item, dom_1 = result.dom;
                widget && _processQueue.push(widget);
                item && _processQueue.push(item);
                dom_1 && _applicationQueue.push(dom_1);
            }
        }
        function _processOne(_a) {
            var current = _a.current, next = _a.next;
            if (current !== next) {
                if (!current && next) {
                    if (isVNodeWrapper(next)) {
                        return _createDom({ next: next });
                    }
                    else {
                        return _createWidget({ next: next });
                    }
                }
                else if (current && next) {
                    if (isVNodeWrapper(current) && isVNodeWrapper(next)) {
                        return _updateDom({ current: current, next: next });
                    }
                    else if (isWNodeWrapper(current) && isWNodeWrapper(next)) {
                        return _updateWidget({ current: current, next: next });
                    }
                }
                else if (current && !next) {
                    if (isVNodeWrapper(current)) {
                        return _removeDom({ current: current });
                    }
                    else if (isWNodeWrapper(current)) {
                        return _removeWidget({ current: current });
                    }
                }
            }
            return {};
        }
        function resolveMiddleware(middlewares, id, middlewareIds) {
            if (middlewareIds === void 0) { middlewareIds = []; }
            var keys = Object.keys(middlewares);
            var results = {};
            var uniqueId = id + "-" + metaId++;
            for (var i = 0; i < keys.length; i++) {
                var middleware = middlewares[keys[i]]();
                var payload = {
                    id: uniqueId,
                    properties: function () {
                        var widgetMeta = widgetMetaMap.get(id);
                        if (widgetMeta) {
                            return tslib_1.__assign({}, widgetMeta.properties);
                        }
                        return {};
                    },
                    children: function () {
                        var widgetMeta = widgetMetaMap.get(id);
                        if (widgetMeta) {
                            return widgetMeta.children;
                        }
                        return [];
                    }
                };
                if (middleware.middlewares) {
                    var resolvedMiddleware = resolveMiddleware(middleware.middlewares, id, middlewareIds).middlewares;
                    payload.middleware = resolvedMiddleware;
                    results[keys[i]] = middleware.callback(payload);
                }
                else {
                    results[keys[i]] = middleware.callback(payload);
                }
            }
            middlewareIds.push(uniqueId);
            return { middlewares: results, ids: middlewareIds };
        }
        function _createWidget(_a) {
            var next = _a.next;
            var widgetConstructor = next.node.widgetConstructor;
            var registry = _mountOptions.registry;
            var Constructor = next.registryItem || widgetConstructor;
            if (!Registry_1.isWidget(Constructor)) {
                resolveRegistryItem(next);
                if (!next.registryItem) {
                    return false;
                }
                Constructor = next.registryItem;
            }
            var rendered;
            var invalidate;
            next.properties = next.node.properties;
            next.id = next.id || "" + wrapperId++;
            _idToWrapperMap.set(next.id, next);
            var id = next.id, depth = next.depth, order = next.order;
            if (!Registry_1.isWidgetBaseConstructor(Constructor)) {
                var widgetMeta = widgetMetaMap.get(id);
                if (!widgetMeta) {
                    invalidate = function () {
                        var widgetMeta = widgetMetaMap.get(id);
                        if (widgetMeta) {
                            widgetMeta.dirty = true;
                            if (!widgetMeta.rendering && _idToWrapperMap.has(id)) {
                                _invalidationQueue.push({ id: id, depth: depth, order: order });
                                _schedule();
                            }
                        }
                    };
                    widgetMeta = {
                        mountNode: _mountOptions.domNode,
                        dirty: false,
                        invalidator: invalidate,
                        properties: next.node.properties,
                        children: next.node.children,
                        deferRefs: 0,
                        rendering: true,
                        middleware: {},
                        middlewareIds: [],
                        registry: _mountOptions.registry
                    };
                    widgetMetaMap.set(next.id, widgetMeta);
                    if (Constructor.middlewares) {
                        var _b = resolveMiddleware(Constructor.middlewares, id), middlewares = _b.middlewares, ids = _b.ids;
                        widgetMeta.middleware = middlewares;
                        widgetMeta.middlewareIds = ids;
                    }
                }
                else {
                    invalidate = widgetMeta.invalidator;
                }
                rendered = Constructor({
                    id: id,
                    properties: function () { return next.node.properties; },
                    children: function () { return next.node.children; },
                    middleware: widgetMeta.middleware
                });
                widgetMeta.rendering = false;
                if (widgetMeta.deferRefs > 0) {
                    return false;
                }
            }
            else {
                var instance = new Constructor();
                instance.registry.base = registry;
                var instanceData_1 = exports.widgetInstanceMap.get(instance);
                invalidate = function () {
                    instanceData_1.dirty = true;
                    if (!instanceData_1.rendering && _idToWrapperMap.has(id)) {
                        _invalidationQueue.push({ id: id, depth: depth, order: order });
                        _schedule();
                    }
                };
                instanceData_1.invalidate = invalidate;
                instanceData_1.rendering = true;
                instance.__setProperties__(next.node.properties);
                instance.__setChildren__(next.node.children);
                next.instance = instance;
                rendered = instance.__render__();
                instanceData_1.rendering = false;
            }
            var children;
            if (rendered) {
                rendered = Array.isArray(rendered) ? rendered : [rendered];
                children = renderedToWrapper(rendered, next, null);
                _idToChildrenWrappers.set(id, children);
            }
            if (!parentInvalidate && !Constructor.isWNodeWrapper) {
                parentInvalidate = invalidate;
            }
            return {
                item: {
                    next: children,
                    meta: { mergeNodes: next.mergeNodes }
                },
                widget: { type: 'attach', instance: next.instance, id: id, attached: true }
            };
        }
        function _updateWidget(_a) {
            var current = _a.current, next = _a.next;
            current = getWNodeWrapper(current.id) || current;
            var instance = current.instance, domNode = current.domNode, hasAnimations = current.hasAnimations;
            var widgetConstructor = next.node.widgetConstructor;
            var Constructor = next.registryItem || widgetConstructor;
            if (!Registry_1.isWidget(Constructor)) {
                return {};
            }
            var rendered;
            var processResult = {};
            var didRender = false;
            var currentChildren = _idToChildrenWrappers.get(current.id);
            next.hasAnimations = hasAnimations;
            next.id = current.id;
            next.childDomWrapperId = current.childDomWrapperId;
            next.properties = next.node.properties;
            _wrapperSiblingMap.delete(current);
            if (domNode && domNode.parentNode) {
                next.domNode = domNode;
            }
            if (!Registry_1.isWidgetBaseConstructor(Constructor)) {
                var widgetMeta_1 = widgetMetaMap.get(next.id);
                if (widgetMeta_1) {
                    widgetMeta_1.properties = next.properties;
                    widgetMeta_1.rendering = true;
                    runDiffs(widgetMeta_1, current.properties, next.properties);
                    if (current.node.children.length > 0 || next.node.children.length > 0) {
                        widgetMeta_1.dirty = true;
                    }
                    if (!widgetMeta_1.dirty) {
                        propertiesDiff(current.properties, next.properties, function () {
                            widgetMeta_1.dirty = true;
                        }, widgetMeta_1.customDiffProperties ? tslib_1.__spread(widgetMeta_1.customDiffProperties.values()) : []);
                    }
                    if (widgetMeta_1.dirty) {
                        _idToChildrenWrappers.delete(next.id);
                        didRender = true;
                        widgetMeta_1.dirty = false;
                        rendered = Constructor({
                            id: next.id,
                            properties: function () { return next.node.properties; },
                            children: function () { return next.node.children; },
                            middleware: widgetMeta_1.middleware
                        });
                        if (widgetMeta_1.deferRefs > 0) {
                            rendered = null;
                        }
                    }
                    widgetMeta_1.rendering = false;
                }
            }
            else {
                var instanceData = exports.widgetInstanceMap.get(instance);
                next.instance = instance;
                instanceData.rendering = true;
                instance.__setProperties__(next.node.properties);
                instance.__setChildren__(next.node.children);
                if (instanceData.dirty) {
                    didRender = true;
                    _idToChildrenWrappers.delete(next.id);
                    rendered = instance.__render__();
                }
                instanceData.rendering = false;
            }
            _idToWrapperMap.set(next.id, next);
            processResult.widget = { type: 'attach', instance: instance, id: next.id, attached: false };
            var children;
            if (rendered) {
                rendered = Array.isArray(rendered) ? rendered : [rendered];
                children = renderedToWrapper(rendered, next, current);
                _idToChildrenWrappers.set(next.id, children);
            }
            if (didRender) {
                processResult.item = {
                    current: currentChildren,
                    next: children,
                    meta: {}
                };
            }
            return processResult;
        }
        function _removeWidget(_a) {
            var current = _a.current;
            current = getWNodeWrapper(current.id) || current;
            _idToWrapperMap.delete(current.id);
            var meta = widgetMetaMap.get(current.id);
            var currentChildren = _idToChildrenWrappers.get(current.id);
            _idToChildrenWrappers.delete(current.id);
            _wrapperSiblingMap.delete(current);
            var processResult = {
                item: {
                    current: currentChildren,
                    meta: {}
                }
            };
            if (meta) {
                meta.registryHandler && meta.registryHandler.destroy();
                destroyHandles(meta);
                widgetMetaMap.delete(current.id);
            }
            else {
                processResult.widget = { type: 'detach', current: current, instance: current.instance };
            }
            return processResult;
        }
        function setDomNodeOnParentWrapper(id) {
            var wrapper = _idToWrapperMap.get(id);
            var children = tslib_1.__spread((_idToChildrenWrappers.get(id) || []));
            var child;
            while (children.length && !wrapper.domNode) {
                child = children.shift();
                if (child) {
                    if (child.domNode) {
                        wrapper.childDomWrapperId = child.id;
                        break;
                    }
                    var nextChildren = _idToChildrenWrappers.get(child.id);
                    if (nextChildren) {
                        children = tslib_1.__spread(nextChildren, children);
                    }
                }
            }
        }
        function _createDom(_a) {
            var next = _a.next;
            var parentDomNode = findParentDomNode(next);
            var isVirtual = isVirtualWrapper(next);
            var isBody = isBodyWrapper(next);
            var mergeNodes = [];
            next.id = "" + wrapperId++;
            _idToWrapperMap.set(next.id, next);
            if (!next.domNode) {
                if (next.node.domNode) {
                    next.domNode = next.node.domNode;
                }
                else {
                    if (next.node.tag === 'svg') {
                        next.namespace = NAMESPACE_SVG;
                    }
                    if (isBody) {
                        next.domNode = global_1.default.document.body;
                    }
                    else if (next.node.tag && !isVirtual) {
                        if (next.namespace) {
                            next.domNode = global_1.default.document.createElementNS(next.namespace, next.node.tag);
                        }
                        else {
                            next.domNode = global_1.default.document.createElement(next.node.tag);
                        }
                    }
                    else if (next.node.text != null) {
                        next.domNode = global_1.default.document.createTextNode(next.node.text);
                    }
                }
                if (_insertBeforeMap && _allMergedNodes.length) {
                    if (parentDomNode === _allMergedNodes[0].parentNode) {
                        _insertBeforeMap.set(next, _allMergedNodes[0]);
                    }
                }
            }
            else if (_mountOptions.merge) {
                next.merged = true;
                if (isTextNode(next.domNode)) {
                    if (next.domNode.data !== next.node.text) {
                        _allMergedNodes = tslib_1.__spread([next.domNode], _allMergedNodes);
                        next.domNode = global_1.default.document.createTextNode(next.node.text);
                        next.merged = false;
                    }
                }
                else {
                    mergeNodes = arrayFrom(next.domNode.childNodes);
                    _allMergedNodes = tslib_1.__spread(_allMergedNodes, mergeNodes);
                }
            }
            var children;
            if (next.domNode || isVirtual) {
                if (next.node.children && next.node.children.length) {
                    children = renderedToWrapper(next.node.children, next, null);
                    _idToChildrenWrappers.set(next.id, children);
                }
            }
            var dom = isVirtual || isBody
                ? undefined
                : {
                    next: next,
                    parentDomNode: parentDomNode,
                    type: 'create'
                };
            if (children) {
                return {
                    item: {
                        current: [],
                        next: children,
                        meta: { mergeNodes: mergeNodes }
                    },
                    dom: dom,
                    widget: isVirtual ? { type: 'attach', id: next.id, attached: false } : undefined
                };
            }
            return { dom: dom };
        }
        function _updateDom(_a) {
            var current = _a.current, next = _a.next;
            next.domNode = current.domNode;
            next.namespace = current.namespace;
            next.id = current.id;
            next.childDomWrapperId = current.childDomWrapperId;
            var children;
            var currentChildren = _idToChildrenWrappers.get(next.id);
            if (next.node.text != null && next.node.text !== current.node.text) {
                next.domNode = global_1.default.document.createTextNode(next.node.text);
            }
            else if (next.node.children) {
                children = renderedToWrapper(next.node.children, next, current);
                _idToChildrenWrappers.set(next.id, children);
            }
            _wrapperSiblingMap.delete(current);
            _idToWrapperMap.set(next.id, next);
            return {
                item: {
                    current: currentChildren,
                    next: children,
                    meta: {}
                },
                dom: { type: 'update', next: next, current: current }
            };
        }
        function _removeDom(_a) {
            var current = _a.current;
            var isVirtual = isVirtualWrapper(current);
            var isBody = isBodyWrapper(current);
            var children = _idToChildrenWrappers.get(current.id);
            _idToChildrenWrappers.delete(current.id);
            _idToWrapperMap.delete(current.id);
            _wrapperSiblingMap.delete(current);
            if (current.node.properties.key) {
                var widgetMeta = widgetMetaMap.get(current.owningId);
                var parentWrapper = getWNodeWrapper(current.owningId);
                if (widgetMeta) {
                    widgetMeta.nodeMap && widgetMeta.nodeMap.delete(current.node.properties.key);
                }
                else if (parentWrapper && parentWrapper.instance) {
                    var instanceData = exports.widgetInstanceMap.get(parentWrapper.instance);
                    instanceData && instanceData.nodeHandler.remove(current.node.properties.key);
                }
            }
            if (current.hasAnimations || isVirtual || isBody) {
                return {
                    item: { current: children, meta: {} },
                    dom: isVirtual || isBody ? undefined : { type: 'delete', current: current }
                };
            }
            if (children) {
                _deferredRenderCallbacks.push(function () {
                    var wrappers = children || [];
                    var wrapper;
                    var bodyIds = [];
                    while ((wrapper = wrappers.pop())) {
                        if (isWNodeWrapper(wrapper)) {
                            wrapper = getWNodeWrapper(wrapper.id) || wrapper;
                            if (wrapper.instance) {
                                var instanceData = exports.widgetInstanceMap.get(wrapper.instance);
                                instanceData && instanceData.onDetach();
                                wrapper.instance = undefined;
                            }
                            else {
                                var meta = widgetMetaMap.get(wrapper.id);
                                if (meta) {
                                    meta.registryHandler && meta.registryHandler.destroy();
                                    destroyHandles(meta);
                                    widgetMetaMap.delete(wrapper.id);
                                }
                            }
                        }
                        var wrapperChildren = _idToChildrenWrappers.get(wrapper.id);
                        if (wrapperChildren) {
                            wrappers.push.apply(wrappers, tslib_1.__spread(wrapperChildren));
                        }
                        if (isBodyWrapper(wrapper)) {
                            bodyIds.push(wrapper.id);
                        }
                        else if (bodyIds.indexOf(wrapper.parentId) !== -1) {
                            if (isWNodeWrapper(wrapper) || isVirtualWrapper(wrapper)) {
                                bodyIds.push(wrapper.id);
                            }
                            else if (wrapper.domNode && wrapper.domNode.parentNode) {
                                wrapper.domNode.parentNode.removeChild(wrapper.domNode);
                            }
                        }
                        _idToChildrenWrappers.delete(wrapper.id);
                        _idToWrapperMap.delete(wrapper.id);
                    }
                });
            }
            return {
                dom: { type: 'delete', current: current }
            };
        }
        return {
            mount: mount,
            invalidate: invalidate
        };
    }
    exports.renderer = renderer;
    exports.default = renderer;
});
//# sourceMappingURL=vdom.js.map