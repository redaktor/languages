{"version":3,"file":"Promise.mjs","sourceRoot":"","sources":["Promise.ts"],"names":[],"mappings":"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","sourcesContent":["import { Thenable } from './interfaces';\nimport global from './global';\n`!has('microtasks')`;\nimport { queueMicroTask } from './support/queue';\n`!has('es6-symbol')`;\nimport './Symbol';\nimport has from '../core/has';\n\n/**\n * Executor is the interface for functions used to initialize a Promise.\n */\nexport interface Executor<T> {\n\t/**\n\t * The executor for the promise\n\t *\n\t * @param resolve The resolver callback of the promise\n\t * @param reject The rejector callback of the promise\n\t */\n\t(resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void): void;\n}\n\ndeclare global {\n\tinterface Promise<T> {\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T>;\n\t}\n}\n\nexport let ShimPromise: typeof Promise = global.Promise;\n\nexport const isThenable = function isThenable<T>(value: any): value is PromiseLike<T> {\n\treturn value && typeof value.then === 'function';\n};\n\nif (!has('es6-promise')) {\n\tconst enum State {\n\t\tFulfilled,\n\t\tPending,\n\t\tRejected\n\t}\n\n\tglobal.Promise = ShimPromise = class Promise<T> implements Thenable<T> {\n\t\tstatic all(iterable: Iterable<any | PromiseLike<any>> | (any | PromiseLike<any>)[]): Promise<any> {\n\t\t\treturn new this(function(resolve, reject) {\n\t\t\t\tconst values: any[] = [];\n\t\t\t\tlet complete = 0;\n\t\t\t\tlet total = 0;\n\t\t\t\tlet populating = true;\n\n\t\t\t\tfunction fulfill(index: number, value: any): void {\n\t\t\t\t\tvalues[index] = value;\n\t\t\t\t\t++complete;\n\t\t\t\t\tfinish();\n\t\t\t\t}\n\n\t\t\t\tfunction finish(): void {\n\t\t\t\t\tif (populating || complete < total) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(values);\n\t\t\t\t}\n\n\t\t\t\tfunction processItem(index: number, item: any): void {\n\t\t\t\t\t++total;\n\t\t\t\t\tif (isThenable(item)) {\n\t\t\t\t\t\t// If an item Promise rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(fulfill.bind(null, index), reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPromise.resolve(item).then(fulfill.bind(null, index));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (const value of iterable) {\n\t\t\t\t\tprocessItem(i, value);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tpopulating = false;\n\n\t\t\t\tfinish();\n\t\t\t});\n\t\t}\n\n\t\tstatic race<T>(iterable: Iterable<T | PromiseLike<T>> | (T | PromiseLike<T>)[]): Promise<T[]> {\n\t\t\treturn new this(function(resolve: (value?: any) => void, reject) {\n\t\t\t\tfor (const item of iterable) {\n\t\t\t\t\tif (item instanceof Promise) {\n\t\t\t\t\t\t// If a Promise item rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(resolve, reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPromise.resolve(item).then(resolve);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tstatic reject(reason?: any): Promise<never> {\n\t\t\treturn new this(function(resolve, reject) {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t}\n\n\t\tstatic resolve(): Promise<void>;\n\t\tstatic resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n\t\tstatic resolve<T>(value?: any): Promise<T> {\n\t\t\treturn new this(function(resolve) {\n\t\t\t\tresolve(<T>value);\n\t\t\t});\n\t\t}\n\n\t\tstatic [Symbol.species]: PromiseConstructor = ShimPromise as PromiseConstructor;\n\n\t\t/**\n\t\t * Creates a new Promise.\n\t\t *\n\t\t * @constructor\n\t\t *\n\t\t * @param executor\n\t\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t\t * starting the asynchronous operation when it is invoked.\n\t\t *\n\t\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t\t * successfully, or the `reject` function when the operation fails.\n\t\t */\n\t\tconstructor(executor: Executor<T>) {\n\t\t\t/**\n\t\t\t * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t\t\t */\n\t\t\tlet isChained = false;\n\n\t\t\t/**\n\t\t\t * Whether or not this promise is in a resolved state.\n\t\t\t */\n\t\t\tconst isResolved = (): boolean => {\n\t\t\t\treturn this.state !== State.Pending || isChained;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Callbacks that should be invoked once the asynchronous operation has completed.\n\t\t\t */\n\t\t\tlet callbacks: null | (Array<() => void>) = [];\n\n\t\t\t/**\n\t\t\t * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t\t\t * enqueues callbacks for execution on the next event loop turn.\n\t\t\t */\n\t\t\tlet whenFinished = function(callback: () => void): void {\n\t\t\t\tif (callbacks) {\n\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Settles this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst settle = (newState: State, value: any): void => {\n\t\t\t\t// A promise can only be settled once.\n\t\t\t\tif (this.state !== State.Pending) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.state = newState;\n\t\t\t\tthis.resolvedValue = value;\n\t\t\t\twhenFinished = queueMicroTask;\n\n\t\t\t\t// Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t\t\t\t// wait an extra turn.\n\t\t\t\tif (callbacks && callbacks.length > 0) {\n\t\t\t\t\tqueueMicroTask(function(): void {\n\t\t\t\t\t\tif (callbacks) {\n\t\t\t\t\t\t\tlet count = callbacks.length;\n\t\t\t\t\t\t\tfor (let i = 0; i < count; ++i) {\n\t\t\t\t\t\t\t\tcallbacks[i].call(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallbacks = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Resolves this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst resolve = (newState: State, value: any): void => {\n\t\t\t\tif (isResolved()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isThenable(value)) {\n\t\t\t\t\tvalue.then(settle.bind(null, State.Fulfilled), settle.bind(null, State.Rejected));\n\t\t\t\t\tisChained = true;\n\t\t\t\t} else {\n\t\t\t\t\tsettle(newState, value);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.then = <TResult1 = T, TResult2 = never>(\n\t\t\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\t\t\tonRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n\t\t\t): Promise<TResult1 | TResult2> => {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t// whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t\t\t\t\t// promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t\t\t\t\t// event loop.\n\t\t\t\t\twhenFinished(() => {\n\t\t\t\t\t\tconst callback: ((value?: any) => any) | undefined | null =\n\t\t\t\t\t\t\tthis.state === State.Rejected ? onRejected : onFulfilled;\n\n\t\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresolve(callback(this.resolvedValue));\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (this.state === State.Rejected) {\n\t\t\t\t\t\t\treject(this.resolvedValue);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(this.resolvedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\texecutor(resolve.bind(null, State.Fulfilled), resolve.bind(null, State.Rejected));\n\t\t\t} catch (error) {\n\t\t\t\tsettle(State.Rejected, error);\n\t\t\t}\n\t\t}\n\n\t\tcatch<TResult = never>(\n\t\t\tonRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n\t\t): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, onRejected);\n\t\t}\n\n\t\t/**\n\t\t * The current state of this promise.\n\t\t */\n\t\tprivate state = State.Pending;\n\n\t\t/**\n\t\t * The resolved value for this promise.\n\t\t *\n\t\t * @type {T|any}\n\t\t */\n\t\tprivate resolvedValue: any;\n\n\t\tthen: <TResult1 = T, TResult2 = never>(\n\t\t\tonfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\t\tonrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n\t\t) => Promise<TResult1 | TResult2>;\n\n\t\t[Symbol.toStringTag]: 'Promise' = 'Promise';\n\t} as any;\n\t// this cast is needed in order to omit finally in the class declaration; this was done so the finally code\n\t// is not duplicated and always added in the conditional below\n}\n\nif (!has('es2018-promise-finally')) {\n\tglobal.Promise.prototype.finally = function<T>(\n\t\tthis: Promise<T>,\n\t\tonFinally: (() => any) | undefined | null\n\t): Promise<any> {\n\t\treturn this.then(\n\t\t\tonFinally && ((value: T) => Promise.resolve(onFinally()).then(() => value)),\n\t\t\tonFinally &&\n\t\t\t\t((reason: any) =>\n\t\t\t\t\tPromise.resolve(onFinally()).then(() => {\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t}))\n\t\t);\n\t};\n}\n\nexport default ShimPromise;\n"]}