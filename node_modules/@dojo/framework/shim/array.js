(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "./iterator", "../core/has", "./support/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    "!has('es6-iterator')";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var iterator_1 = require("./iterator");
    var has_1 = require("../core/has");
    var util_1 = require("./support/util");
    // Util functions for filled implementations
    var toLength;
    var toInteger;
    var normalizeOffset;
    if (!has_1.default('es6-array') || !has_1.default('es6-array-fill') || !has_1.default('es7-array')) {
        var MAX_SAFE_INTEGER_1 = Math.pow(2, 53) - 1;
        /**
         * Ensures a non-negative, non-infinite, safe integer.
         *
         * @param length The number to validate
         * @return A proper length
         */
        toLength = function toLength(length) {
            if (isNaN(length)) {
                return 0;
            }
            length = Number(length);
            if (isFinite(length)) {
                length = Math.floor(length);
            }
            // Ensure a non-negative, real, safe integer
            return Math.min(Math.max(length, 0), MAX_SAFE_INTEGER_1);
        };
        /**
         * From ES6 7.1.4 ToInteger()
         *
         * @param value A value to convert
         * @return An integer
         */
        toInteger = function toInteger(value) {
            value = Number(value);
            if (isNaN(value)) {
                return 0;
            }
            if (value === 0 || !isFinite(value)) {
                return value;
            }
            return (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));
        };
        /**
         * Normalizes an offset against a given length, wrapping it if negative.
         *
         * @param value The original offset
         * @param length The total length to normalize against
         * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0
         */
        normalizeOffset = function normalizeOffset(value, length) {
            return value < 0 ? Math.max(length + value, 0) : Math.min(value, length);
        };
    }
    if (!has_1.default('es6-array')) {
        Array.from = function from(arrayLike, mapFunction, thisArg) {
            var e_1, _a;
            if (arrayLike == null) {
                throw new TypeError('from: requires an array-like object');
            }
            if (mapFunction && thisArg) {
                mapFunction = mapFunction.bind(thisArg);
            }
            /* tslint:disable-next-line:variable-name */
            var Constructor = this;
            var length = toLength(arrayLike.length);
            // Support extension
            var array = typeof Constructor === 'function' ? Object(new Constructor(length)) : new Array(length);
            if (!iterator_1.isArrayLike(arrayLike) && !iterator_1.isIterable(arrayLike)) {
                return array;
            }
            // if this is an array and the normalized length is 0, just return an empty array. this prevents a problem
            // with the iteration on IE when using a NaN array length.
            if (iterator_1.isArrayLike(arrayLike)) {
                if (length === 0) {
                    return [];
                }
                for (var i = 0; i < arrayLike.length; i++) {
                    array[i] = mapFunction ? mapFunction(arrayLike[i], i) : arrayLike[i];
                }
            }
            else {
                var i = 0;
                try {
                    for (var arrayLike_1 = tslib_1.__values(arrayLike), arrayLike_1_1 = arrayLike_1.next(); !arrayLike_1_1.done; arrayLike_1_1 = arrayLike_1.next()) {
                        var value = arrayLike_1_1.value;
                        array[i] = mapFunction ? mapFunction(value, i) : value;
                        i++;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (arrayLike_1_1 && !arrayLike_1_1.done && (_a = arrayLike_1.return)) _a.call(arrayLike_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            if (arrayLike.length !== undefined) {
                array.length = length;
            }
            return array;
        };
        Array.of = function of() {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return Array.prototype.slice.call(items);
        };
        Array.prototype.copyWithin = function copyWithin(offset, start, end) {
            if (this == null) {
                throw new TypeError('copyWithin: target must be an array-like object');
            }
            var length = toLength(this.length);
            offset = normalizeOffset(toInteger(offset), length);
            start = normalizeOffset(toInteger(start), length);
            end = normalizeOffset(end === undefined ? length : toInteger(end), length);
            var count = Math.min(end - start, length - offset);
            var direction = 1;
            if (offset > start && offset < start + count) {
                direction = -1;
                start += count - 1;
                offset += count - 1;
            }
            while (count > 0) {
                if (start in this) {
                    this[offset] = this[start];
                }
                else {
                    delete this[offset];
                }
                offset += direction;
                start += direction;
                count--;
            }
            return this;
        };
        Array.prototype.find = function find(callback, thisArg) {
            var index = this.findIndex(callback, thisArg);
            return index !== -1 ? this[index] : undefined;
        };
        Array.prototype.findIndex = function findIndex(callback, thisArg) {
            var length = toLength(this.length);
            if (!callback) {
                throw new TypeError('find: second argument must be a function');
            }
            if (thisArg) {
                callback = callback.bind(thisArg);
            }
            for (var i = 0; i < length; i++) {
                if (callback(this[i], i, this)) {
                    return i;
                }
            }
            return -1;
        };
    }
    if (!has_1.default('es6-array-fill')) {
        Array.prototype.fill = function fill(value, start, end) {
            var length = toLength(this.length);
            var i = normalizeOffset(toInteger(start), length);
            end = normalizeOffset(end === undefined ? length : toInteger(end), length);
            while (i < (end || 0)) {
                this[i++] = value;
            }
            return this;
        };
    }
    if (!has_1.default('es7-array')) {
        Array.prototype.includes = function includes(searchElement, fromIndex) {
            if (fromIndex === void 0) { fromIndex = 0; }
            var len = toLength(this.length);
            for (var i = fromIndex; i < len; ++i) {
                var currentElement = this[i];
                if (searchElement === currentElement ||
                    (searchElement !== searchElement && currentElement !== currentElement)) {
                    return true;
                }
            }
            return false;
        };
    }
    exports.from = Array.from;
    exports.of = Array.of;
    exports.copyWithin = util_1.wrapNative(Array.prototype.copyWithin);
    exports.fill = util_1.wrapNative(Array.prototype.fill);
    exports.find = util_1.wrapNative(Array.prototype.find);
    exports.findIndex = util_1.wrapNative(Array.prototype.findIndex);
    exports.includes = util_1.wrapNative(Array.prototype.includes);
    exports.default = Array;
});
//# sourceMappingURL=array.js.map