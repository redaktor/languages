{"version":3,"file":"iterator.mjs","sourceRoot":"","sources":["iterator.ts"],"names":[],"mappings":"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","sourcesContent":["`!has('es6-symbol')`;\nimport './Symbol';\nimport { HIGH_SURROGATE_MAX, HIGH_SURROGATE_MIN } from './string';\n\nexport interface IteratorResult<T> {\n\treadonly done: boolean;\n\treadonly value: T;\n}\n\nexport interface Iterator<T> {\n\tnext(value?: any): IteratorResult<T>;\n\n\treturn?(value?: any): IteratorResult<T>;\n\n\tthrow?(e?: any): IteratorResult<T>;\n}\n\nexport interface Iterable<T> {\n\t[Symbol.iterator](): Iterator<T>;\n}\n\nexport interface IterableIterator<T> extends Iterator<T> {\n\t[Symbol.iterator](): IterableIterator<T>;\n}\n\nconst staticDone: IteratorResult<any> = { done: true, value: undefined };\n\n/**\n * A class that _shims_ an iterator interface on array like objects.\n */\nexport class ShimIterator<T> {\n\tprivate _list: ArrayLike<T> | undefined;\n\tprivate _nextIndex = -1;\n\tprivate _nativeIterator: Iterator<T> | undefined;\n\n\tconstructor(list: ArrayLike<T> | Iterable<T>) {\n\t\tif (isIterable(list)) {\n\t\t\tthis._nativeIterator = list[Symbol.iterator]();\n\t\t} else {\n\t\t\tthis._list = list;\n\t\t}\n\t}\n\n\t/**\n\t * Return the next iteration result for the Iterator\n\t */\n\tnext(): IteratorResult<T> {\n\t\tif (this._nativeIterator) {\n\t\t\treturn this._nativeIterator.next();\n\t\t}\n\t\tif (!this._list) {\n\t\t\treturn staticDone;\n\t\t}\n\t\tif (++this._nextIndex < this._list.length) {\n\t\t\treturn {\n\t\t\t\tdone: false,\n\t\t\t\tvalue: this._list[this._nextIndex]\n\t\t\t};\n\t\t}\n\t\treturn staticDone;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this;\n\t}\n}\n\n/**\n * A type guard for checking if something has an Iterable interface\n *\n * @param value The value to type guard against\n */\nexport function isIterable(value: any): value is Iterable<any> {\n\treturn value && typeof value[Symbol.iterator] === 'function';\n}\n\n/**\n * A type guard for checking if something is ArrayLike\n *\n * @param value The value to type guard against\n */\nexport function isArrayLike(value: any): value is ArrayLike<any> {\n\treturn value && typeof value.length === 'number';\n}\n\n/**\n * Returns the iterator for an object\n *\n * @param iterable The iterable object to return the iterator for\n */\nexport function get<T>(iterable: Iterable<T> | ArrayLike<T>): Iterator<T> | undefined {\n\tif (isIterable(iterable)) {\n\t\treturn iterable[Symbol.iterator]();\n\t} else if (isArrayLike(iterable)) {\n\t\treturn new ShimIterator(iterable);\n\t}\n}\n\nexport interface ForOfCallback<T> {\n\t/**\n\t * A callback function for a forOf() iteration\n\t *\n\t * @param value The current value\n\t * @param object The object being iterated over\n\t * @param doBreak A function, if called, will stop the iteration\n\t */\n\t(value: T, object: Iterable<T> | ArrayLike<T> | string, doBreak: () => void): void;\n}\n\n/**\n * Shims the functionality of `for ... of` blocks\n *\n * @param iterable The object the provides an iterator interface\n * @param callback The callback which will be called for each item of the iterable\n * @param thisArg Optional scope to pass the callback\n */\nexport function forOf<T>(\n\titerable: Iterable<T> | ArrayLike<T> | string,\n\tcallback: ForOfCallback<T | string>,\n\tthisArg?: any\n): void {\n\tlet broken = false;\n\n\tfunction doBreak() {\n\t\tbroken = true;\n\t}\n\n\t/* We need to handle iteration of double byte strings properly */\n\tif (isArrayLike(iterable) && typeof iterable === 'string') {\n\t\tconst l = iterable.length;\n\t\tfor (let i = 0; i < l; ++i) {\n\t\t\tlet char = iterable[i];\n\t\t\tif (i + 1 < l) {\n\t\t\t\tconst code = char.charCodeAt(0);\n\t\t\t\tif (code >= HIGH_SURROGATE_MIN && code <= HIGH_SURROGATE_MAX) {\n\t\t\t\t\tchar += iterable[++i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback.call(thisArg, char, iterable, doBreak);\n\t\t\tif (broken) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst iterator = get(iterable);\n\t\tif (iterator) {\n\t\t\tlet result = iterator.next();\n\n\t\t\twhile (!result.done) {\n\t\t\t\tcallback.call(thisArg, result.value, iterable, doBreak);\n\t\t\t\tif (broken) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresult = iterator.next();\n\t\t\t}\n\t\t}\n\t}\n}\n"]}