import has from '../core/has';
export let assign;
/**
 * Gets the own property descriptor of the specified object.
 * An own property descriptor is one that is defined directly on the object and is not
 * inherited from the object's prototype.
 * @param o Object that contains the property.
 * @param p Name of the property.
 */
export let getOwnPropertyDescriptor;
/**
 * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly
 * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.
 * @param o Object that contains the own properties.
 */
export let getOwnPropertyNames;
/**
 * Returns an array of all symbol properties found directly on object o.
 * @param o Object to retrieve the symbols from.
 */
export let getOwnPropertySymbols;
/**
 * Returns true if the values are the same value, false otherwise.
 * @param value1 The first value.
 * @param value2 The second value.
 */
export let is;
/**
 * Returns the names of the enumerable properties and methods of an object.
 * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.
 */
export let keys;
/* ES7 Object static methods */
export let getOwnPropertyDescriptors;
export let entries;
export let values;
if (!has('es6-object')) {
    const keys = Object.keys.bind(Object);
    Object.keys = function symbolAwareKeys(o) {
        return keys(o).filter((key) => !Boolean(key.match(/^@@.+/)));
    };
    Object.assign = function assign(target, ...sources) {
        if (target == null) {
            // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }
        const to = Object(target);
        sources.forEach((nextSource) => {
            if (nextSource) {
                // Skip over if undefined or null
                keys(nextSource).forEach((nextKey) => {
                    to[nextKey] = nextSource[nextKey];
                });
            }
        });
        return to;
    };
    const getOwnPropertyNames = Object.getOwnPropertyNames.bind(Object);
    Object.getOwnPropertyNames = function symbolAwareGetOwnPropertyNames(o) {
        return getOwnPropertyNames(o).filter((key) => !Boolean(key.match(/^@@.+/)));
    };
    Object.getOwnPropertySymbols = function getOwnPropertySymbols(o) {
        return getOwnPropertyNames(o)
            .filter((key) => Boolean(key.match(/^@@.+/)))
            .map((key) => Symbol.for(key.substring(2)));
    };
    Object.is = function is(value1, value2) {
        if (value1 === value2) {
            return value1 !== 0 || 1 / value1 === 1 / value2; // -0
        }
        return value1 !== value1 && value2 !== value2; // NaN
    };
}
if (!has('es2017-object')) {
    Object.getOwnPropertyDescriptors = function getOwnPropertyDescriptors(o) {
        return Object.getOwnPropertyNames(o).reduce((previous, key) => {
            previous[key] = Object.getOwnPropertyDescriptor(o, key);
            return previous;
        }, {});
    };
    Object.entries = function entries(o) {
        return keys(o).map((key) => [key, o[key]]);
    };
    Object.values = function values(o) {
        return keys(o).map((key) => o[key]);
    };
}
assign = Object.assign;
getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
getOwnPropertyNames = Object.getOwnPropertyNames;
getOwnPropertySymbols = Object.getOwnPropertySymbols;
is = Object.is;
keys = Object.keys;
getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors;
entries = Object.entries;
values = Object.values;
export default Object;
//# sourceMappingURL=object.mjs.map