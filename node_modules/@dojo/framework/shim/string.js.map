{"version":3,"file":"string.js","sourceRoot":"","sources":["string.ts"],"names":[],"mappings":"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","sourcesContent":["import has from '../core/has';\nimport { wrapNative } from './support/util';\n\nexport interface StringNormalize {\n\t/**\n\t * Returns the String value result of normalizing the string into the normalization form\n\t * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n\t * @param target The target string\n\t * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n\t * is \"NFC\"\n\t */\n\t(target: string, form: 'NFC' | 'NFD' | 'NFKC' | 'NFKD'): string;\n\n\t/**\n\t * Returns the String value result of normalizing the string into the normalization form\n\t * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n\t * @param target The target string\n\t * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n\t * is \"NFC\"\n\t */\n\t(target: string, form?: string): string;\n}\n\n/**\n * The minimum location of high surrogates\n */\nexport const HIGH_SURROGATE_MIN = 0xd800;\n\n/**\n * The maximum location of high surrogates\n */\nexport const HIGH_SURROGATE_MAX = 0xdbff;\n\n/**\n * The minimum location of low surrogates\n */\nexport const LOW_SURROGATE_MIN = 0xdc00;\n\n/**\n * The maximum location of low surrogates\n */\nexport const LOW_SURROGATE_MAX = 0xdfff;\n\n/* ES6 static methods */\n\n/**\n * Return the String value whose elements are, in order, the elements in the List elements.\n * If length is 0, the empty string is returned.\n * @param codePoints The code points to generate the string\n */\nexport let fromCodePoint: (...codePoints: number[]) => string;\n\n/**\n * `raw` is intended for use as a tag function of a Tagged Template String. When called\n * as such the first argument will be a well formed template call site object and the rest\n * parameter will contain the substitution values.\n * @param template A well-formed template string call site representation.\n * @param substitutions A set of substitution values.\n */\nexport let raw: (template: TemplateStringsArray, ...substitutions: any[]) => string;\n\n/* ES6 instance methods */\n\n/**\n * Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\n * value of the UTF-16 encoded code point starting at the string element at position pos in\n * the String resulting from converting this object to a String.\n * If there is no element at that position, the result is undefined.\n * If a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.\n */\nexport let codePointAt: (target: string, pos: number) => number | undefined;\n\n/**\n * Returns true if the sequence of elements of searchString converted to a String is the\n * same as the corresponding elements of this object (converted to a String) starting at\n * endPosition â€“ length(this). Otherwise returns false.\n */\nexport let endsWith: (target: string, searchString: string, endPosition?: number) => boolean;\n\n/**\n * Returns true if searchString appears as a substring of the result of converting this\n * object to a String, at one or more positions that are\n * greater than or equal to position; otherwise, returns false.\n * @param target The target string\n * @param searchString search string\n * @param position If position is undefined, 0 is assumed, so as to search all of the String.\n */\nexport let includes: (target: string, searchString: string, position?: number) => boolean;\n\n/**\n * Returns the String value result of normalizing the string into the normalization form\n * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n * @param target The target string\n * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n * is \"NFC\"\n */\nexport let normalize: StringNormalize;\n\n/**\n * Returns a String value that is made from count copies appended together. If count is 0,\n * T is the empty String is returned.\n * @param count number of copies to append\n */\nexport let repeat: (target: string, count: number) => string;\n\n/**\n * Returns true if the sequence of elements of searchString converted to a String is the\n * same as the corresponding elements of this object (converted to a String) starting at\n * position. Otherwise returns false.\n */\nexport let startsWith: (target: string, searchString: string, position?: number) => boolean;\n\n/* ES7 instance methods */\n\n/**\n * Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\n * The padding is applied from the end (right) of the current string.\n *\n * @param target The target string\n * @param maxLength The length of the resulting string once the current string has been padded.\n *        If this parameter is smaller than the current string's length, the current string will be returned as it is.\n *\n * @param fillString The string to pad the current string with.\n *        If this string is too long, it will be truncated and the left-most part will be applied.\n *        The default value for this parameter is \" \" (U+0020).\n */\nexport let padEnd: (target: string, maxLength: number, fillString?: string) => string;\n\n/**\n * Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\n * The padding is applied from the start (left) of the current string.\n *\n * @param target The target string\n * @param maxLength The length of the resulting string once the current string has been padded.\n *        If this parameter is smaller than the current string's length, the current string will be returned as it is.\n *\n * @param fillString The string to pad the current string with.\n *        If this string is too long, it will be truncated and the left-most part will be applied.\n *        The default value for this parameter is \" \" (U+0020).\n */\nexport let padStart: (target: string, maxLength: number, fillString?: string) => string;\n\nif (!has('es6-string')) {\n\t/**\n\t * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).\n\t * Used by startsWith, includes, and endsWith.\n\t *\n\t * @return Normalized position.\n\t */\n\tconst normalizeSubstringArgs = function(\n\t\tname: string,\n\t\ttext: string,\n\t\tsearch: string,\n\t\tposition: number,\n\t\tisEnd: boolean = false\n\t): [string, string, number] {\n\t\tif (text == null) {\n\t\t\tthrow new TypeError('string.' + name + ' requires a valid string to search against.');\n\t\t}\n\n\t\tconst length = text.length;\n\t\tposition = position !== position ? (isEnd ? length : 0) : position;\n\t\treturn [text, String(search), Math.min(Math.max(position, 0), length)];\n\t};\n\n\tString.fromCodePoint = function fromCodePoint(...codePoints: number[]): string {\n\t\t// Adapted from https://github.com/mathiasbynens/String.fromCodePoint\n\t\tconst length = arguments.length;\n\t\tif (!length) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromCharCode = String.fromCharCode;\n\t\tconst MAX_SIZE = 0x4000;\n\t\tlet codeUnits: number[] = [];\n\t\tlet index = -1;\n\t\tlet result = '';\n\n\t\twhile (++index < length) {\n\t\t\tlet codePoint = Number(arguments[index]);\n\n\t\t\t// Code points must be finite integers within the valid range\n\t\t\tlet isValid =\n\t\t\t\tisFinite(codePoint) && Math.floor(codePoint) === codePoint && codePoint >= 0 && codePoint <= 0x10ffff;\n\t\t\tif (!isValid) {\n\t\t\t\tthrow RangeError('string.fromCodePoint: Invalid code point ' + codePoint);\n\t\t\t}\n\n\t\t\tif (codePoint <= 0xffff) {\n\t\t\t\t// BMP code point\n\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t} else {\n\t\t\t\t// Astral code point; split in surrogate halves\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\tlet highSurrogate = (codePoint >> 10) + HIGH_SURROGATE_MIN;\n\t\t\t\tlet lowSurrogate = (codePoint % 0x400) + LOW_SURROGATE_MIN;\n\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t}\n\n\t\t\tif (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t\t\t\tresult += fromCharCode.apply(null, codeUnits);\n\t\t\t\tcodeUnits.length = 0;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\tString.prototype.codePointAt = function codePointAt(position: number = 0): number | undefined {\n\t\t// Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt\n\t\tif (this == null) {\n\t\t\tthrow new TypeError('string.codePointAt requries a valid string.');\n\t\t}\n\t\tconst length = this.length;\n\n\t\tif (position !== position) {\n\t\t\tposition = 0;\n\t\t}\n\t\tif (position < 0 || position >= length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Get the first code unit\n\t\tconst first = this.charCodeAt(position);\n\t\tif (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > position + 1) {\n\t\t\t// Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate\n\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\tconst second = this.charCodeAt(position + 1);\n\t\t\tif (second >= LOW_SURROGATE_MIN && second <= LOW_SURROGATE_MAX) {\n\t\t\t\treturn (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;\n\t\t\t}\n\t\t}\n\t\treturn first;\n\t};\n\n\tString.prototype.endsWith = function endsWith(search: string, endPosition?: number): boolean {\n\t\tlet text = this.toString();\n\t\tif (search === '') {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (typeof endPosition === 'undefined') {\n\t\t\tendPosition = text.length;\n\t\t} else if (endPosition === null || isNaN(endPosition)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t[text, search, endPosition] = normalizeSubstringArgs('endsWith', text, search, endPosition, true);\n\n\t\tconst start = endPosition - search.length;\n\t\tif (start < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn text.slice(start, endPosition) === search;\n\t};\n\n\tString.prototype.includes = function includes(search: string, position: number = 0): boolean {\n\t\tlet text = this.toString();\n\t\t[text, search, position] = normalizeSubstringArgs('includes', text, search, position);\n\t\treturn text.indexOf(search, position) !== -1;\n\t};\n\n\tString.prototype.repeat = function repeat(count: number = 0): string {\n\t\t// Adapted from https://github.com/mathiasbynens/String.prototype.repeat\n\t\tlet text = this.toString();\n\t\tif (text == null) {\n\t\t\tthrow new TypeError('string.repeat requires a valid string.');\n\t\t}\n\t\tif (count !== count) {\n\t\t\tcount = 0;\n\t\t}\n\t\tif (count < 0 || count === Infinity) {\n\t\t\tthrow new RangeError('string.repeat requires a non-negative finite count.');\n\t\t}\n\n\t\tlet result = '';\n\t\twhile (count) {\n\t\t\tif (count % 2) {\n\t\t\t\tresult += text;\n\t\t\t}\n\t\t\tif (count > 1) {\n\t\t\t\ttext += text;\n\t\t\t}\n\t\t\tcount >>= 1;\n\t\t}\n\t\treturn result;\n\t};\n\n\tString.prototype.startsWith = function startsWith(search: string, position: number = 0): boolean {\n\t\tlet text = this.toString();\n\t\tsearch = String(search);\n\t\t[text, search, position] = normalizeSubstringArgs('startsWith', text, search, position);\n\n\t\tconst end = position + search.length;\n\t\tif (end > text.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn text.slice(position, end) === search;\n\t};\n}\n\nif (!has('es6-string-raw')) {\n\tString.raw = function raw(callSite: TemplateStringsArray, ...substitutions: any[]): string {\n\t\tlet rawStrings = callSite.raw;\n\t\tlet result = '';\n\t\tlet numSubstitutions = substitutions.length;\n\n\t\tif (callSite == null || callSite.raw == null) {\n\t\t\tthrow new TypeError('string.raw requires a valid callSite object with a raw value');\n\t\t}\n\n\t\tfor (let i = 0, length = rawStrings.length; i < length; i++) {\n\t\t\tresult += rawStrings[i] + (i < numSubstitutions && i < length - 1 ? substitutions[i] : '');\n\t\t}\n\n\t\treturn result;\n\t};\n}\n\nif (!has('es2017-string')) {\n\tString.prototype.padEnd = function padEnd(maxLength: number, fillString: string = ' '): string {\n\t\tif (this === null || this === undefined) {\n\t\t\tthrow new TypeError('string.repeat requires a valid string.');\n\t\t}\n\n\t\tif (maxLength === Infinity) {\n\t\t\tthrow new RangeError('string.padEnd requires a non-negative finite count.');\n\t\t}\n\n\t\tif (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t\t\tmaxLength = 0;\n\t\t}\n\n\t\tlet strText = String(this);\n\t\tconst padding = maxLength - strText.length;\n\n\t\tif (padding > 0) {\n\t\t\tstrText +=\n\t\t\t\trepeat(fillString, Math.floor(padding / fillString.length)) +\n\t\t\t\tfillString.slice(0, padding % fillString.length);\n\t\t}\n\n\t\treturn strText;\n\t};\n\n\tString.prototype.padStart = function padStart(maxLength: number, fillString: string = ' '): string {\n\t\tif (this === null || this === undefined) {\n\t\t\tthrow new TypeError('string.repeat requires a valid string.');\n\t\t}\n\n\t\tif (maxLength === Infinity) {\n\t\t\tthrow new RangeError('string.padStart requires a non-negative finite count.');\n\t\t}\n\n\t\tif (maxLength === null || maxLength === undefined || maxLength < 0) {\n\t\t\tmaxLength = 0;\n\t\t}\n\n\t\tlet strText = String(this);\n\t\tconst padding = maxLength - strText.length;\n\n\t\tif (padding > 0) {\n\t\t\tstrText =\n\t\t\t\trepeat(fillString, Math.floor(padding / fillString.length)) +\n\t\t\t\tfillString.slice(0, padding % fillString.length) +\n\t\t\t\tstrText;\n\t\t}\n\n\t\treturn strText;\n\t};\n}\n\nfromCodePoint = String.fromCodePoint;\nraw = String.raw;\n\ncodePointAt = wrapNative(String.prototype.codePointAt);\nendsWith = wrapNative(String.prototype.endsWith);\nincludes = wrapNative(String.prototype.includes);\nnormalize = wrapNative(String.prototype.normalize);\nrepeat = wrapNative(String.prototype.repeat);\nstartsWith = wrapNative(String.prototype.startsWith);\npadEnd = wrapNative(String.prototype.padEnd);\npadStart = wrapNative(String.prototype.padStart);\n\nexport default String;\n"]}