{"version":3,"file":"Store.js","sourceRoot":"","sources":["Store.ts"],"names":[],"mappings":"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","sourcesContent":["import { Evented } from '../core/Evented';\nimport { Patch, PatchOperation } from './state/Patch';\nimport { Pointer } from './state/Pointer';\nimport Map from '../shim/Map';\n\n/**\n * The \"path\" to a value of type T on and object of type M. The path string is a JSON Pointer to the location of\n * `value` within `state`.\n *\n */\nexport interface Path<M, T> {\n\tpath: string;\n\tstate: M;\n\tvalue: T;\n}\n\n/**\n * An interface that enables typed traversal of an arbitrary type M. `path` and `at` can be used to generate\n * `Path`s that allow access to properties within M via the `get` method. The returned `Path`s can also be passed to the\n * utility methods `add`, `replace`, and `delete` in order to generate typed operations for modifying the state of a store.\n */\nexport interface State<M> {\n\tget<S>(path: Path<M, S>): S;\n\tat<S extends Path<M, Array<any>>>(path: S, index: number): Path<M, S['value'][0]>;\n\tpath: StatePaths<M>;\n}\n\nexport interface StatePaths<M> {\n\t<T, P0 extends keyof Required<T>>(path: Path<M, T>, a: P0): Path<M, Required<T>[P0]>;\n\t<T, P0 extends keyof T, P1 extends keyof Required<T>[P0]>(path: Path<M, T>, a: P0, b: P1): Path<\n\t\tM,\n\t\tRequired<Required<T>[P0]>[P1]\n\t>;\n\t<T, P0 extends keyof T, P1 extends keyof Required<T>[P0], P2 extends keyof Required<Required<T>[P0]>[P1]>(\n\t\tpath: Path<M, T>,\n\t\ta: P0,\n\t\tb: P1,\n\t\tc: P2\n\t): Path<M, Required<Required<Required<T>[P0]>[P1]>[P2]>;\n\t<\n\t\tT,\n\t\tP0 extends keyof T,\n\t\tP1 extends keyof Required<T>[P0],\n\t\tP2 extends keyof Required<Required<T>[P0]>[P1],\n\t\tP3 extends keyof Required<Required<Required<T>[P0]>[P1]>[P2]\n\t>(\n\t\tpath: Path<M, T>,\n\t\ta: P0,\n\t\tb: P1,\n\t\tc: P2,\n\t\td: P3\n\t): Path<M, Required<Required<Required<Required<T>[P0]>[P1]>[P2]>[P3]>;\n\t<\n\t\tT,\n\t\tP0 extends keyof T,\n\t\tP1 extends keyof Required<T>[P0],\n\t\tP2 extends keyof Required<Required<T>[P0]>[P1],\n\t\tP3 extends keyof Required<Required<Required<T>[P0]>[P1]>[P2],\n\t\tP4 extends keyof Required<Required<Required<Required<T>[P0]>[P1]>[P2]>[P3]\n\t>(\n\t\tpath: Path<M, T>,\n\t\ta: P0,\n\t\tb: P1,\n\t\tc: P2,\n\t\td: P3,\n\t\te: P4\n\t): Path<M, Required<Required<Required<Required<Required<T>[P0]>[P1]>[P2]>[P3]>[P4]>;\n\t<P0 extends keyof M>(a: P0): Path<M, Required<M>[P0]>;\n\t<P0 extends keyof M, P1 extends keyof Required<M>[P0]>(a: P0, b: P1): Path<M, Required<Required<M>[P0]>[P1]>;\n\t<P0 extends keyof M, P1 extends keyof Required<M>[P0], P2 extends keyof Required<Required<M>[P0]>[P1]>(\n\t\ta: P0,\n\t\tb: P1,\n\t\tc: P2\n\t): Path<M, Required<Required<Required<M>[P0]>[P1]>[P2]>;\n\t<\n\t\tP0 extends keyof M,\n\t\tP1 extends keyof Required<M>[P0],\n\t\tP2 extends keyof Required<Required<M>[P0]>[P1],\n\t\tP3 extends keyof Required<Required<Required<M>[P0]>[P1]>[P2]\n\t>(\n\t\ta: P0,\n\t\tb: P1,\n\t\tc: P2,\n\t\td: P3\n\t): Path<M, Required<Required<Required<Required<M>[P0]>[P1]>[P2]>[P3]>;\n\t<\n\t\tP0 extends keyof M,\n\t\tP1 extends keyof Required<M>[P0],\n\t\tP2 extends keyof Required<Required<M>[P0]>[P1],\n\t\tP3 extends keyof Required<Required<Required<M>[P0]>[P1]>[P2],\n\t\tP4 extends keyof Required<Required<Required<Required<M>[P0]>[P1]>[P2]>[P3]\n\t>(\n\t\ta: P0,\n\t\tb: P1,\n\t\tc: P2,\n\t\td: P3,\n\t\te: P4\n\t): Path<M, Required<Required<Required<Required<Required<M>[P0]>[P1]>[P2]>[P3]>[P4]>;\n}\n\ninterface OnChangeCallback {\n\tcallbackId: number;\n\tcallback: () => void;\n}\n\ninterface OnChangeValue {\n\tcallbacks: OnChangeCallback[];\n\tpreviousValue: any;\n}\n\nfunction isString(segment?: string): segment is string {\n\treturn typeof segment === 'string';\n}\n\nexport interface MutableState<T = any> extends State<T> {\n\t/**\n\t * Applies store operations to state and returns the undo operations\n\t */\n\tapply(operations: PatchOperation<T>[]): PatchOperation<T>[];\n}\n\nexport class DefaultState<T = any> implements MutableState<T> {\n\t/**\n\t * The private state object\n\t */\n\tprivate _state = {} as T;\n\n\t/**\n\t * Returns the state at a specific pointer path location.\n\t */\n\tpublic get = <U = any>(path: Path<T, U>): U => {\n\t\treturn path.value;\n\t};\n\n\t/**\n\t * Applies store operations to state and returns the undo operations\n\t */\n\tpublic apply = (operations: PatchOperation<T>[]): PatchOperation<T>[] => {\n\t\tconst patch = new Patch(operations);\n\t\tconst patchResult = patch.apply(this._state);\n\t\tthis._state = patchResult.object;\n\t\treturn patchResult.undoOperations;\n\t};\n\n\tpublic at = <U = any>(path: Path<T, Array<U>>, index: number): Path<T, U> => {\n\t\tconst array = this.get(path);\n\t\tconst value = array && array[index];\n\n\t\treturn {\n\t\t\tpath: `${path.path}/${index}`,\n\t\t\tstate: path.state,\n\t\t\tvalue\n\t\t};\n\t};\n\n\tpublic path: State<T>['path'] = (path: string | Path<T, any>, ...segments: (string | undefined)[]) => {\n\t\tif (typeof path === 'string') {\n\t\t\tsegments = [path, ...segments];\n\t\t} else {\n\t\t\tsegments = [...new Pointer(path.path).segments, ...segments];\n\t\t}\n\n\t\tconst stringSegments = segments.filter<string>(isString);\n\t\tconst hasMultipleSegments = stringSegments.length > 1;\n\t\tconst pointer = new Pointer(hasMultipleSegments ? stringSegments : stringSegments[0] || '');\n\n\t\treturn {\n\t\t\tpath: pointer.path,\n\t\t\tstate: this._state,\n\t\t\tvalue: pointer.get(this._state)\n\t\t};\n\t};\n}\n\n/**\n * Application state store\n */\nexport class Store<T = any> extends Evented implements MutableState<T> {\n\tprivate _adapter: MutableState<T> = new DefaultState<T>();\n\n\tprivate _changePaths = new Map<string, OnChangeValue>();\n\n\tprivate _callbackId = 0;\n\n\t/**\n\t * Returns the state at a specific pointer path location.\n\t */\n\tpublic get = <U = any>(path: Path<T, U>): U => {\n\t\treturn this._adapter.get(path);\n\t};\n\n\tconstructor(options?: { state?: MutableState<T> }) {\n\t\tsuper();\n\t\tif (options && options.state) {\n\t\t\tthis._adapter = options.state;\n\t\t\tthis.path = this._adapter.path.bind(this._adapter);\n\t\t}\n\t}\n\n\t/**\n\t * Applies store operations to state and returns the undo operations\n\t */\n\tpublic apply = (operations: PatchOperation<T>[], invalidate: boolean = false): PatchOperation<T>[] => {\n\t\tconst result = this._adapter.apply(operations);\n\n\t\tif (invalidate) {\n\t\t\tthis.invalidate();\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tpublic at = <U = any>(path: Path<T, Array<U>>, index: number): Path<T, U> => {\n\t\treturn this._adapter.at(path, index);\n\t};\n\n\tpublic onChange = <U = any>(paths: Path<T, U> | Path<T, U>[], callback: () => void) => {\n\t\tconst callbackId = this._callbackId;\n\t\tif (!Array.isArray(paths)) {\n\t\t\tpaths = [paths];\n\t\t}\n\t\tpaths.forEach((path) => this._addOnChange(path, callback, callbackId));\n\t\tthis._callbackId += 1;\n\t\treturn {\n\t\t\tremove: () => {\n\t\t\t\t(paths as Path<T, U>[]).forEach((path) => {\n\t\t\t\t\tconst onChange = this._changePaths.get(path.path);\n\t\t\t\t\tif (onChange) {\n\t\t\t\t\t\tonChange.callbacks = onChange.callbacks.filter((callback) => {\n\t\t\t\t\t\t\treturn callback.callbackId !== callbackId;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t};\n\n\tprivate _addOnChange = <U = any>(path: Path<T, U>, callback: () => void, callbackId: number): void => {\n\t\tlet changePaths = this._changePaths.get(path.path);\n\t\tif (!changePaths) {\n\t\t\tchangePaths = { callbacks: [], previousValue: this.get(path) };\n\t\t}\n\t\tchangePaths.callbacks.push({ callbackId, callback });\n\t\tthis._changePaths.set(path.path, changePaths);\n\t};\n\n\tprivate _runOnChanges() {\n\t\tconst callbackIdsCalled: number[] = [];\n\t\tthis._changePaths.forEach((value: OnChangeValue, path: string) => {\n\t\t\tconst { previousValue, callbacks } = value;\n\t\t\tconst pointer = new Pointer(path);\n\t\t\tconst newValue = pointer.segments.length\n\t\t\t\t? (this._adapter as any).path(pointer.segments[0] as keyof T, ...pointer.segments.slice(1)).value\n\t\t\t\t: undefined;\n\t\t\tif (previousValue !== newValue) {\n\t\t\t\tthis._changePaths.set(path, { callbacks, previousValue: newValue });\n\t\t\t\tcallbacks.forEach((callbackItem) => {\n\t\t\t\t\tconst { callback, callbackId } = callbackItem;\n\t\t\t\t\tif (callbackIdsCalled.indexOf(callbackId) === -1) {\n\t\t\t\t\t\tcallbackIdsCalled.push(callbackId);\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Emits an invalidation event\n\t */\n\tpublic invalidate(): any {\n\t\tthis._runOnChanges();\n\t\tthis.emit({ type: 'invalidate' });\n\t}\n\n\tpublic path: State<T>['path'] = this._adapter.path.bind(this._adapter);\n}\n\nexport default Store;\n"]}