{"version":3,"file":"StoreInjector.js","sourceRoot":"","sources":["StoreInjector.ts"],"names":[],"mappings":"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","sourcesContent":["import WeakMap from '../shim/WeakMap';\nimport { WidgetBase } from '../core/WidgetBase';\nimport { handleDecorator } from '../core/decorators/handleDecorator';\nimport { beforeProperties } from '../core/decorators/beforeProperties';\nimport { alwaysRender } from '../core/decorators/alwaysRender';\nimport { InjectorItem, RegistryLabel, Constructor, DNode } from '../core/interfaces';\nimport { Store, Path } from './Store';\nimport { Registry } from '../core/Registry';\nimport { GetPaths } from './StoreProvider';\nimport { w } from '../core/vdom';\nexport { GetPaths } from './StoreProvider';\nconst registeredInjectorsMap: WeakMap<WidgetBase, InjectorItem<Store>[]> = new WeakMap();\n\nexport interface GetProperties<S extends Store, W extends WidgetBase<any, any> = WidgetBase<any, any>> {\n\t(payload: S, properties: W['properties']): W['properties'];\n}\n\nexport type StoreContainerPath<\n\tS,\n\tP0 extends keyof S = keyof S,\n\tP1 extends keyof S[P0] = keyof S[P0],\n\tP2 extends keyof S[P0][P1] = keyof S[P0][P1],\n\tP3 extends keyof S[P0][P1][P2] = keyof S[P0][P1][P2],\n\tP4 extends keyof S[P0][P1][P2][P3] = keyof S[P0][P1][P2][P3]\n> = [P0] | [P0, P1] | [P0, P1, P2] | [P0, P1, P2, P3] | [P0, P1, P2, P3, P4];\n\nexport interface StoreContainerOptions<S, W extends WidgetBase> {\n\tpaths?: GetPaths<S> | StoreContainerPath<S>[];\n\tgetProperties: GetProperties<Store<S>, W>;\n}\n\nexport interface StoreInjectConfig<S = any> {\n\tname: RegistryLabel;\n\tgetProperties: GetProperties<Store<S>, any>;\n\tpaths?: StoreContainerPath<S>[] | GetPaths<S>;\n}\n\nexport type StoreContainer<T extends WidgetBase<any, any>> = Constructor<\n\tWidgetBase<Partial<T['properties']>, T['children'][0]>\n>;\n\n/**\n * Decorator that registers a store injector with a container based on paths when provided\n *\n * @param config Configuration of the store injector\n */\nexport function storeInject<S>(config: StoreInjectConfig<S>) {\n\tconst { name, paths, getProperties } = config;\n\n\treturn handleDecorator((target, propertyKey) => {\n\t\tbeforeProperties(function(this: WidgetBase & { own: Function }, properties: any) {\n\t\t\tconst injectorItem = this.registry.getInjector<Store<S>>(name);\n\t\t\tif (injectorItem) {\n\t\t\t\tconst { injector } = injectorItem;\n\t\t\t\tconst store = injector();\n\t\t\t\tconst registeredInjectors = registeredInjectorsMap.get(this) || [];\n\t\t\t\tif (registeredInjectors.length === 0) {\n\t\t\t\t\tregisteredInjectorsMap.set(this, registeredInjectors);\n\t\t\t\t}\n\t\t\t\tif (registeredInjectors.indexOf(injectorItem) === -1) {\n\t\t\t\t\tif (paths) {\n\t\t\t\t\t\tlet invalidatePaths: Path<S, any>[];\n\t\t\t\t\t\tif (typeof paths === 'function') {\n\t\t\t\t\t\t\tinvalidatePaths = paths(store.path);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinvalidatePaths = paths.map((path: any) => store.path(path.join('/')));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst handle = store.onChange(invalidatePaths, () => this.invalidate());\n\t\t\t\t\t\tthis.own({\n\t\t\t\t\t\t\tdestroy: () => {\n\t\t\t\t\t\t\t\thandle.remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.own(\n\t\t\t\t\t\t\tstore.on('invalidate', () => {\n\t\t\t\t\t\t\t\tthis.invalidate();\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tregisteredInjectors.push(injectorItem);\n\t\t\t\t}\n\t\t\t\treturn getProperties(store, properties);\n\t\t\t}\n\t\t})(target);\n\t});\n}\n\nexport function StoreContainer<S = any, W extends WidgetBase<any, any> = WidgetBase<any, any>>(\n\tcomponent: Constructor<W> | RegistryLabel,\n\tname: RegistryLabel,\n\t{ paths, getProperties }: StoreContainerOptions<S, W>\n): StoreContainer<W> {\n\t@alwaysRender()\n\t@storeInject({ name, paths, getProperties })\n\tclass WidgetContainer extends WidgetBase<Partial<W['properties']>, W['children'][0]> {\n\t\tprotected render(): DNode {\n\t\t\treturn w(component, this.properties, this.children);\n\t\t}\n\t}\n\treturn WidgetContainer;\n}\n\n/**\n * Creates a typed `StoreContainer` for State generic.\n */\nexport function createStoreContainer<S>() {\n\treturn <W extends WidgetBase<any, any>>(\n\t\tcomponent: Constructor<W> | RegistryLabel,\n\t\tname: RegistryLabel,\n\t\t{ paths, getProperties }: StoreContainerOptions<S, W>\n\t) => {\n\t\treturn StoreContainer(component, name, { paths, getProperties });\n\t};\n}\n\nexport interface StoreInjectorOptions {\n\tkey?: RegistryLabel;\n\tregistry?: Registry;\n}\n\nexport function registerStoreInjector<T>(store: Store<T>, options: StoreInjectorOptions = {}) {\n\tconst { key = 'state', registry = new Registry() } = options;\n\n\tif (registry.hasInjector(key)) {\n\t\tthrow new Error(`Store has already been defined for key ${key.toString()}`);\n\t}\n\tregistry.defineInjector(key, () => {\n\t\treturn () => store;\n\t});\n\treturn registry;\n}\n"]}