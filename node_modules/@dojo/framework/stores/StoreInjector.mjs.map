{"version":3,"file":"StoreInjector.mjs","sourceRoot":"","sources":["StoreInjector.ts"],"names":[],"mappings":"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","sourcesContent":["import WeakMap from '../shim/WeakMap';\nimport { WidgetBase } from '../core/WidgetBase';\nimport { handleDecorator } from '../core/decorators/handleDecorator';\nimport { beforeProperties } from '../core/decorators/beforeProperties';\nimport { alwaysRender } from '../core/decorators/alwaysRender';\nimport { InjectorItem, RegistryLabel, Constructor, DNode } from '../core/interfaces';\nimport { Store, Path } from './Store';\nimport { Registry } from '../core/Registry';\nimport { GetPaths } from './StoreProvider';\nimport { w } from '../core/vdom';\nexport { GetPaths } from './StoreProvider';\nconst registeredInjectorsMap: WeakMap<WidgetBase, InjectorItem<Store>[]> = new WeakMap();\n\nexport interface GetProperties<S extends Store, W extends WidgetBase<any, any> = WidgetBase<any, any>> {\n\t(payload: S, properties: W['properties']): W['properties'];\n}\n\nexport type StoreContainerPath<\n\tS,\n\tP0 extends keyof S = keyof S,\n\tP1 extends keyof S[P0] = keyof S[P0],\n\tP2 extends keyof S[P0][P1] = keyof S[P0][P1],\n\tP3 extends keyof S[P0][P1][P2] = keyof S[P0][P1][P2],\n\tP4 extends keyof S[P0][P1][P2][P3] = keyof S[P0][P1][P2][P3]\n> = [P0] | [P0, P1] | [P0, P1, P2] | [P0, P1, P2, P3] | [P0, P1, P2, P3, P4];\n\nexport interface StoreContainerOptions<S, W extends WidgetBase> {\n\tpaths?: GetPaths<S> | StoreContainerPath<S>[];\n\tgetProperties: GetProperties<Store<S>, W>;\n}\n\nexport interface StoreInjectConfig<S = any> {\n\tname: RegistryLabel;\n\tgetProperties: GetProperties<Store<S>, any>;\n\tpaths?: StoreContainerPath<S>[] | GetPaths<S>;\n}\n\nexport type StoreContainer<T extends WidgetBase<any, any>> = Constructor<\n\tWidgetBase<Partial<T['properties']>, T['children'][0]>\n>;\n\n/**\n * Decorator that registers a store injector with a container based on paths when provided\n *\n * @param config Configuration of the store injector\n */\nexport function storeInject<S>(config: StoreInjectConfig<S>) {\n\tconst { name, paths, getProperties } = config;\n\n\treturn handleDecorator((target, propertyKey) => {\n\t\tbeforeProperties(function(this: WidgetBase & { own: Function }, properties: any) {\n\t\t\tconst injectorItem = this.registry.getInjector<Store<S>>(name);\n\t\t\tif (injectorItem) {\n\t\t\t\tconst { injector } = injectorItem;\n\t\t\t\tconst store = injector();\n\t\t\t\tconst registeredInjectors = registeredInjectorsMap.get(this) || [];\n\t\t\t\tif (registeredInjectors.length === 0) {\n\t\t\t\t\tregisteredInjectorsMap.set(this, registeredInjectors);\n\t\t\t\t}\n\t\t\t\tif (registeredInjectors.indexOf(injectorItem) === -1) {\n\t\t\t\t\tif (paths) {\n\t\t\t\t\t\tlet invalidatePaths: Path<S, any>[];\n\t\t\t\t\t\tif (typeof paths === 'function') {\n\t\t\t\t\t\t\tinvalidatePaths = paths(store.path);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinvalidatePaths = paths.map((path: any) => store.path(path.join('/')));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst handle = store.onChange(invalidatePaths, () => this.invalidate());\n\t\t\t\t\t\tthis.own({\n\t\t\t\t\t\t\tdestroy: () => {\n\t\t\t\t\t\t\t\thandle.remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.own(\n\t\t\t\t\t\t\tstore.on('invalidate', () => {\n\t\t\t\t\t\t\t\tthis.invalidate();\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tregisteredInjectors.push(injectorItem);\n\t\t\t\t}\n\t\t\t\treturn getProperties(store, properties);\n\t\t\t}\n\t\t})(target);\n\t});\n}\n\nexport function StoreContainer<S = any, W extends WidgetBase<any, any> = WidgetBase<any, any>>(\n\tcomponent: Constructor<W> | RegistryLabel,\n\tname: RegistryLabel,\n\t{ paths, getProperties }: StoreContainerOptions<S, W>\n): StoreContainer<W> {\n\t@alwaysRender()\n\t@storeInject({ name, paths, getProperties })\n\tclass WidgetContainer extends WidgetBase<Partial<W['properties']>, W['children'][0]> {\n\t\tprotected render(): DNode {\n\t\t\treturn w(component, this.properties, this.children);\n\t\t}\n\t}\n\treturn WidgetContainer;\n}\n\n/**\n * Creates a typed `StoreContainer` for State generic.\n */\nexport function createStoreContainer<S>() {\n\treturn <W extends WidgetBase<any, any>>(\n\t\tcomponent: Constructor<W> | RegistryLabel,\n\t\tname: RegistryLabel,\n\t\t{ paths, getProperties }: StoreContainerOptions<S, W>\n\t) => {\n\t\treturn StoreContainer(component, name, { paths, getProperties });\n\t};\n}\n\nexport interface StoreInjectorOptions {\n\tkey?: RegistryLabel;\n\tregistry?: Registry;\n}\n\nexport function registerStoreInjector<T>(store: Store<T>, options: StoreInjectorOptions = {}) {\n\tconst { key = 'state', registry = new Registry() } = options;\n\n\tif (registry.hasInjector(key)) {\n\t\tthrow new Error(`Store has already been defined for key ${key.toString()}`);\n\t}\n\tregistry.defineInjector(key, () => {\n\t\treturn () => store;\n\t});\n\treturn registry;\n}\n"]}