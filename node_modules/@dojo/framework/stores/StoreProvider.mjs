var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import WidgetBase from '../core/WidgetBase';
import { diffProperty } from '../core/decorators/diffProperty';
import { shallow } from '../core/diff';
import { alwaysRender } from '../core/decorators/alwaysRender';
function mockPath(...paths) {
    return paths.join(',');
}
function pathDiff(previousProperty, newProperty) {
    const previousPaths = previousProperty ? previousProperty(mockPath) : [];
    const currentPaths = newProperty ? newProperty(mockPath) : [];
    const result = shallow(previousPaths, currentPaths);
    return {
        changed: result.changed,
        value: newProperty
    };
}
let StoreProvider = class StoreProvider extends WidgetBase {
    _getStore(key) {
        const item = this.registry.getInjector(key);
        if (item) {
            return item.injector();
        }
    }
    _getProperties() {
        return Object.assign({ stateKey: 'state' }, this.properties);
    }
    onChange(previousProperties, currentProperties) {
        const { stateKey = 'state', paths } = currentProperties;
        if (this._handle) {
            this._handle.destroy();
            this._handle = undefined;
        }
        const store = this._getStore(stateKey);
        if (store) {
            if (paths) {
                const handle = store.onChange(paths(store.path), () => this.invalidate());
                this._handle = {
                    destroy: () => {
                        handle.remove();
                    }
                };
            }
            else {
                this._handle = store.on('invalidate', () => {
                    this.invalidate();
                });
            }
            this.own(this._handle);
        }
    }
    render() {
        const { stateKey, renderer } = this._getProperties();
        const store = this._getStore(stateKey);
        if (!this._handle) {
            this.onChange({}, this._getProperties());
        }
        if (store) {
            return renderer(store);
        }
    }
};
__decorate([
    diffProperty('stateKey'),
    diffProperty('paths', pathDiff)
], StoreProvider.prototype, "onChange", null);
StoreProvider = __decorate([
    alwaysRender()
], StoreProvider);
export { StoreProvider };
export default StoreProvider;
//# sourceMappingURL=StoreProvider.mjs.map