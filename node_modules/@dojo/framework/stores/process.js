(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../shim/Promise", "./state/operations", "../shim/Map", "../core/has"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var Promise_1 = require("../shim/Promise");
    var operations_1 = require("./state/operations");
    var Map_1 = require("../shim/Map");
    var has_1 = require("../core/has");
    /**
     * Creates a command factory with the specified type
     */
    function createCommandFactory() {
        function commandFactory(command) {
            return command;
        }
        return commandFactory;
    }
    exports.createCommandFactory = createCommandFactory;
    var processMap = new Map_1.default();
    var valueSymbol = Symbol('value');
    function isStateProxy(value) {
        if (typeof value !== 'object' || value === null) {
            return false;
        }
        return Boolean(value[valueSymbol]);
    }
    exports.isStateProxy = isStateProxy;
    function getProcess(id) {
        return processMap.get(id);
    }
    exports.getProcess = getProcess;
    var proxyError = 'State updates are not available on legacy browsers';
    function removeProxies(value) {
        if (typeof value === 'object' && value !== null) {
            if (value[valueSymbol]) {
                value = value[valueSymbol];
            }
            var newValue = Array.isArray(value) ? [] : {};
            var keys = Object.keys(value);
            for (var i = 0; i < keys.length; i++) {
                newValue[keys[i]] = removeProxies(value[keys[i]]);
            }
            value = newValue;
        }
        return value;
    }
    function processExecutor(id, commands, store, before, after, transformer) {
        var _this = this;
        var apply = store.apply, get = store.get, path = store.path, at = store.at;
        function executor(process, payload, transformer) {
            return process(store)(payload);
        }
        return function (executorPayload) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            function createProxy() {
                var proxies = new Map_1.default();
                var proxied = new Map_1.default();
                var proxyOperations = [];
                var createHandler = function (partialPath) { return ({
                    get: function (obj, prop) {
                        var fullPath = partialPath ? path(partialPath, prop) : path(prop);
                        var stringPath = fullPath.path;
                        if (typeof prop === 'symbol' && prop === valueSymbol) {
                            return proxied.get(stringPath);
                        }
                        var value = partialPath || obj.hasOwnProperty(prop) ? obj[prop] : get(fullPath);
                        if (typeof value === 'object' && value !== null) {
                            var proxiedValue = void 0;
                            if (!proxies.has(stringPath)) {
                                if (Array.isArray(value)) {
                                    value = value.slice();
                                }
                                else {
                                    value = tslib_1.__assign({}, value);
                                }
                                proxiedValue = new Proxy(value, createHandler(fullPath));
                                proxies.set(stringPath, proxiedValue);
                                proxied.set(stringPath, value);
                            }
                            else {
                                proxiedValue = proxies.get(stringPath);
                            }
                            obj[prop] = value;
                            return proxiedValue;
                        }
                        obj[prop] = value;
                        return value;
                    },
                    set: function (obj, prop, value) {
                        value = removeProxies(value);
                        proxyOperations.push(operations_1.replace(partialPath ? path(partialPath, prop) : path(prop), value));
                        obj[prop] = value;
                        return true;
                    },
                    deleteProperty: function (obj, prop) {
                        proxyOperations.push(operations_1.remove(partialPath ? path(partialPath, prop) : path(prop)));
                        delete obj[prop];
                        return true;
                    }
                }); };
                return { proxy: new Proxy({}, createHandler()), operations: proxyOperations };
            }
            var operations, commandsCopy, undoOperations, command, error, payload, result, results, commandArray, resolvedResults, i, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        operations = [];
                        commandsCopy = tslib_1.__spread(commands);
                        undoOperations = [];
                        command = commandsCopy.shift();
                        error = null;
                        payload = transformer ? transformer(executorPayload) : executorPayload;
                        if (!before) return [3 /*break*/, 2];
                        result = before(payload, store, id);
                        if (!result) return [3 /*break*/, 2];
                        return [4 /*yield*/, result];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 8, , 9]);
                        _a.label = 3;
                    case 3:
                        if (!command) return [3 /*break*/, 7];
                        results = [];
                        commandArray = Array.isArray(command) ? command : [command];
                        results = commandArray.map(function (commandFunction) {
                            var state;
                            var proxyOperations = [];
                            if (typeof Proxy !== 'undefined') {
                                var _a = createProxy(), operations_2 = _a.operations, proxy = _a.proxy;
                                state = proxy;
                                proxyOperations = operations_2;
                            }
                            var result = commandFunction({
                                at: at,
                                get: get,
                                path: path,
                                payload: payload,
                                get state() {
                                    if (typeof Proxy === 'undefined') {
                                        throw new Error(proxyError);
                                    }
                                    return state;
                                }
                            });
                            if (Promise_1.isThenable(result)) {
                                return result.then(function (result) {
                                    result = result ? tslib_1.__spread(proxyOperations, result) : tslib_1.__spread(proxyOperations);
                                    return result;
                                });
                            }
                            else {
                                result =
                                    result && Array.isArray(result) ? tslib_1.__spread(proxyOperations, result) : tslib_1.__spread(proxyOperations);
                                return result;
                            }
                        });
                        resolvedResults = void 0;
                        if (!results.some(Promise_1.isThenable)) return [3 /*break*/, 5];
                        return [4 /*yield*/, Promise.all(results)];
                    case 4:
                        resolvedResults = _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        resolvedResults = results;
                        _a.label = 6;
                    case 6:
                        for (i = 0; i < results.length; i++) {
                            operations.push.apply(operations, tslib_1.__spread(resolvedResults[i]));
                            undoOperations = tslib_1.__spread(apply(resolvedResults[i]), undoOperations);
                        }
                        store.invalidate();
                        command = commandsCopy.shift();
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        e_1 = _a.sent();
                        if (e_1.message === proxyError) {
                            throw e_1;
                        }
                        error = { error: e_1, command: command };
                        return [3 /*break*/, 9];
                    case 9:
                        after &&
                            after(error, {
                                undoOperations: undoOperations,
                                store: store,
                                id: id,
                                operations: operations,
                                apply: apply,
                                at: at,
                                get: get,
                                path: path,
                                executor: executor,
                                payload: payload
                            });
                        return [2 /*return*/, Promise.resolve({
                                store: store,
                                undoOperations: undoOperations,
                                id: id,
                                error: error,
                                operations: operations,
                                apply: apply,
                                at: at,
                                get: get,
                                path: path,
                                executor: executor,
                                payload: payload
                            })];
                }
            });
        }); };
    }
    exports.processExecutor = processExecutor;
    /**
     * Factories a process using the provided commands and an optional callback. Returns an executor used to run the process.
     *
     * @param commands The commands for the process
     * @param callback Callback called after the process is completed
     */
    function createProcess(id, commands, callbacks) {
        callbacks = Array.isArray(callbacks) ? callbacks : callbacks ? [callbacks] : [];
        var callback = callbacks.length
            ? callbacks.reduce(function (callback, nextCallback) {
                return combineCallbacks(nextCallback, id)(callback);
            })
            : undefined;
        var _a = callback ? callback() : {}, _b = _a.before, before = _b === void 0 ? undefined : _b, _c = _a.after, after = _c === void 0 ? undefined : _c;
        processMap.set(id, [id, commands, before, after]);
        return function (store, transformer) {
            return processExecutor(id, commands, store, before, after, transformer);
        };
    }
    exports.createProcess = createProcess;
    /**
     * Creates a process factory that will create processes with the specified callback decorators applied.
     * @param callbacks array of process callback to be used by the returned factory.
     * @param initializers array of process initializers to be used by the returned factory.
     */
    function createProcessFactoryWith(callbacks) {
        return function (id, commands, callback) {
            return createProcess(id, commands, callback ? tslib_1.__spread(callbacks, [callback]) : callbacks);
        };
    }
    exports.createProcessFactoryWith = createProcessFactoryWith;
    /**
     * Creates a `ProcessCallbackDecorator` from a `ProcessCallback`.
     * @param processCallback the process callback to convert to a decorator.
     * @param id process id to be passed to the before callback
     */
    function combineCallbacks(processCallback, id) {
        var _a = processCallback(), before = _a.before, after = _a.after;
        return function (previousCallback) {
            var _a = previousCallback
                ? previousCallback()
                : {}, _b = _a.before, previousBefore = _b === void 0 ? undefined : _b, _c = _a.after, previousAfter = _c === void 0 ? undefined : _c;
            return function () { return ({
                after: function (error, result) {
                    if (previousAfter) {
                        previousAfter(error, result);
                    }
                    if (after) {
                        after(error, result);
                    }
                },
                before: function (payload, store) {
                    if (previousBefore) {
                        previousBefore(payload, store, id);
                    }
                    if (before) {
                        before(payload, store, id);
                    }
                }
            }); };
        };
    }
    function createCallbackDecorator(callback) {
        if (has_1.default('dojo-debug')) {
            console.warn('Process using the the legacy middleware API. Please update to use the latest API, see https://github.com/dojo/framework/blob/master/docs/V5-Migration-Guide.md for details.');
        }
        var convertedCallback = function () { return ({
            after: callback
        }); };
        return function (callbacks) {
            if (callbacks === void 0) { callbacks = []; }
            return tslib_1.__spread([convertedCallback], callbacks);
        };
    }
    exports.createCallbackDecorator = createCallbackDecorator;
});
//# sourceMappingURL=process.js.map