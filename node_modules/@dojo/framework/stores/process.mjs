import { isThenable } from '../shim/Promise';
import { replace, remove } from './state/operations';
import Map from '../shim/Map';
import has from '../core/has';
/**
 * Creates a command factory with the specified type
 */
export function createCommandFactory() {
    function commandFactory(command) {
        return command;
    }
    return commandFactory;
}
const processMap = new Map();
const valueSymbol = Symbol('value');
export function isStateProxy(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    return Boolean(value[valueSymbol]);
}
export function getProcess(id) {
    return processMap.get(id);
}
const proxyError = 'State updates are not available on legacy browsers';
function removeProxies(value) {
    if (typeof value === 'object' && value !== null) {
        if (value[valueSymbol]) {
            value = value[valueSymbol];
        }
        const newValue = Array.isArray(value) ? [] : {};
        const keys = Object.keys(value);
        for (let i = 0; i < keys.length; i++) {
            newValue[keys[i]] = removeProxies(value[keys[i]]);
        }
        value = newValue;
    }
    return value;
}
export function processExecutor(id, commands, store, before, after, transformer) {
    const { apply, get, path, at } = store;
    function executor(process, payload, transformer) {
        return process(store)(payload);
    }
    return async (executorPayload) => {
        const operations = [];
        const commandsCopy = [...commands];
        let undoOperations = [];
        let command = commandsCopy.shift();
        let error = null;
        const payload = transformer ? transformer(executorPayload) : executorPayload;
        if (before) {
            let result = before(payload, store, id);
            if (result) {
                await result;
            }
        }
        function createProxy() {
            const proxies = new Map();
            const proxied = new Map();
            const proxyOperations = [];
            const createHandler = (partialPath) => ({
                get(obj, prop) {
                    const fullPath = partialPath ? path(partialPath, prop) : path(prop);
                    const stringPath = fullPath.path;
                    if (typeof prop === 'symbol' && prop === valueSymbol) {
                        return proxied.get(stringPath);
                    }
                    let value = partialPath || obj.hasOwnProperty(prop) ? obj[prop] : get(fullPath);
                    if (typeof value === 'object' && value !== null) {
                        let proxiedValue;
                        if (!proxies.has(stringPath)) {
                            if (Array.isArray(value)) {
                                value = value.slice();
                            }
                            else {
                                value = Object.assign({}, value);
                            }
                            proxiedValue = new Proxy(value, createHandler(fullPath));
                            proxies.set(stringPath, proxiedValue);
                            proxied.set(stringPath, value);
                        }
                        else {
                            proxiedValue = proxies.get(stringPath);
                        }
                        obj[prop] = value;
                        return proxiedValue;
                    }
                    obj[prop] = value;
                    return value;
                },
                set(obj, prop, value) {
                    value = removeProxies(value);
                    proxyOperations.push(replace(partialPath ? path(partialPath, prop) : path(prop), value));
                    obj[prop] = value;
                    return true;
                },
                deleteProperty(obj, prop) {
                    proxyOperations.push(remove(partialPath ? path(partialPath, prop) : path(prop)));
                    delete obj[prop];
                    return true;
                }
            });
            return { proxy: new Proxy({}, createHandler()), operations: proxyOperations };
        }
        try {
            while (command) {
                let results = [];
                const commandArray = Array.isArray(command) ? command : [command];
                results = commandArray.map((commandFunction) => {
                    let state;
                    let proxyOperations = [];
                    if (typeof Proxy !== 'undefined') {
                        const { operations, proxy } = createProxy();
                        state = proxy;
                        proxyOperations = operations;
                    }
                    let result = commandFunction({
                        at,
                        get,
                        path,
                        payload,
                        get state() {
                            if (typeof Proxy === 'undefined') {
                                throw new Error(proxyError);
                            }
                            return state;
                        }
                    });
                    if (isThenable(result)) {
                        return result.then((result) => {
                            result = result ? [...proxyOperations, ...result] : [...proxyOperations];
                            return result;
                        });
                    }
                    else {
                        result =
                            result && Array.isArray(result) ? [...proxyOperations, ...result] : [...proxyOperations];
                        return result;
                    }
                });
                let resolvedResults;
                if (results.some(isThenable)) {
                    resolvedResults = await Promise.all(results);
                }
                else {
                    resolvedResults = results;
                }
                for (let i = 0; i < results.length; i++) {
                    operations.push(...resolvedResults[i]);
                    undoOperations = [...apply(resolvedResults[i]), ...undoOperations];
                }
                store.invalidate();
                command = commandsCopy.shift();
            }
        }
        catch (e) {
            if (e.message === proxyError) {
                throw e;
            }
            error = { error: e, command };
        }
        after &&
            after(error, {
                undoOperations,
                store,
                id,
                operations,
                apply,
                at,
                get,
                path,
                executor,
                payload
            });
        return Promise.resolve({
            store,
            undoOperations,
            id,
            error,
            operations,
            apply,
            at,
            get,
            path,
            executor,
            payload
        });
    };
}
/**
 * Factories a process using the provided commands and an optional callback. Returns an executor used to run the process.
 *
 * @param commands The commands for the process
 * @param callback Callback called after the process is completed
 */
export function createProcess(id, commands, callbacks) {
    callbacks = Array.isArray(callbacks) ? callbacks : callbacks ? [callbacks] : [];
    const callback = callbacks.length
        ? callbacks.reduce((callback, nextCallback) => {
            return combineCallbacks(nextCallback, id)(callback);
        })
        : undefined;
    const { before = undefined, after = undefined } = callback ? callback() : {};
    processMap.set(id, [id, commands, before, after]);
    return (store, transformer) => processExecutor(id, commands, store, before, after, transformer);
}
/**
 * Creates a process factory that will create processes with the specified callback decorators applied.
 * @param callbacks array of process callback to be used by the returned factory.
 * @param initializers array of process initializers to be used by the returned factory.
 */
export function createProcessFactoryWith(callbacks) {
    return (id, commands, callback) => {
        return createProcess(id, commands, callback ? [...callbacks, callback] : callbacks);
    };
}
/**
 * Creates a `ProcessCallbackDecorator` from a `ProcessCallback`.
 * @param processCallback the process callback to convert to a decorator.
 * @param id process id to be passed to the before callback
 */
function combineCallbacks(processCallback, id) {
    const { before, after } = processCallback();
    return (previousCallback) => {
        const { before: previousBefore = undefined, after: previousAfter = undefined } = previousCallback
            ? previousCallback()
            : {};
        return () => ({
            after(error, result) {
                if (previousAfter) {
                    previousAfter(error, result);
                }
                if (after) {
                    after(error, result);
                }
            },
            before(payload, store) {
                if (previousBefore) {
                    previousBefore(payload, store, id);
                }
                if (before) {
                    before(payload, store, id);
                }
            }
        });
    };
}
export function createCallbackDecorator(callback) {
    if (has('dojo-debug')) {
        console.warn('Process using the the legacy middleware API. Please update to use the latest API, see https://github.com/dojo/framework/blob/master/docs/V5-Migration-Guide.md for details.');
    }
    const convertedCallback = () => ({
        after: callback
    });
    return (callbacks = []) => {
        return [convertedCallback, ...callbacks];
    };
}
//# sourceMappingURL=process.mjs.map