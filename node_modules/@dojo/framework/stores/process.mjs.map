{"version":3,"file":"process.mjs","sourceRoot":"","sources":["process.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAE7C,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAC;AAErD,OAAO,GAAG,MAAM,aAAa,CAAC;AAC9B,OAAO,GAAG,MAAM,aAAa,CAAC;AAiJ9B;;GAEG;AACH,MAAM,UAAU,oBAAoB;IAKnC,SAAS,cAAc,CAAuB,OAAsB;QACnE,OAAO,OAAO,CAAC;IAChB,CAAC;IACD,OAAO,cAAc,CAAC;AACvB,CAAC;AAOD,MAAM,UAAU,GAAG,IAAI,GAAG,EAAE,CAAC;AAC7B,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;AAEpC,MAAM,UAAU,YAAY,CAAC,KAAU;IACtC,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,EAAE;QAChD,OAAO,KAAK,CAAC;KACb;IAED,OAAO,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC;AACpC,CAAC;AAED,MAAM,UAAU,UAAU,CAAC,EAAU;IACpC,OAAO,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;AAC3B,CAAC;AAED,MAAM,UAAU,GAAG,oDAAoD,CAAC;AAExE,SAAS,aAAa,CAAC,KAAU;IAChC,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,EAAE;QAChD,IAAI,KAAK,CAAC,WAAW,CAAC,EAAE;YACvB,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC,CAAC;SAC3B;QAED,MAAM,QAAQ,GAAiB,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;QAC9D,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SAClD;QAED,KAAK,GAAG,QAAQ,CAAC;KACjB;IAED,OAAO,KAAK,CAAC;AACd,CAAC;AAED,MAAM,UAAU,eAAe,CAC9B,EAAU,EACV,QAAwB,EACxB,KAAe,EACf,MAAyC,EACzC,KAAuC,EACvC,WAAuC;IAEvC,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,KAAK,CAAC;IACvC,SAAS,QAAQ,CAChB,OAAgB,EAChB,OAAY,EACZ,WAAyB;QAEzB,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC;IAChC,CAAC;IAED,OAAO,KAAK,EAAE,eAAkB,EAAgC,EAAE;QACjE,MAAM,UAAU,GAAqB,EAAE,CAAC;QACxC,MAAM,YAAY,GAAG,CAAC,GAAG,QAAQ,CAAC,CAAC;QACnC,IAAI,cAAc,GAAqB,EAAE,CAAC;QAC1C,IAAI,OAAO,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;QACnC,IAAI,KAAK,GAAwB,IAAI,CAAC;QACtC,MAAM,OAAO,GAAG,WAAW,CAAC,CAAC,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC;QAE7E,IAAI,MAAM,EAAE;YACX,IAAI,MAAM,GAAG,MAAM,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;YACxC,IAAI,MAAM,EAAE;gBACX,MAAM,MAAM,CAAC;aACb;SACD;QAED,SAAS,WAAW;YACnB,MAAM,OAAO,GAAG,IAAI,GAAG,EAAe,CAAC;YACvC,MAAM,OAAO,GAAG,IAAI,GAAG,EAAe,CAAC;YAEvC,MAAM,eAAe,GAAqB,EAAE,CAAC;YAC7C,MAAM,aAAa,GAAG,CAAC,WAA0B,EAAE,EAAE,CAAC,CAAC;gBACtD,GAAG,CAAC,GAAQ,EAAE,IAAY;oBACzB,MAAM,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAe,CAAC,CAAC;oBAC/E,MAAM,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC;oBAEjC,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,KAAK,WAAW,EAAE;wBACrD,OAAO,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;qBAC/B;oBAED,IAAI,KAAK,GAAG,WAAW,IAAI,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;oBAEhF,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,EAAE;wBAChD,IAAI,YAAY,CAAC;wBACjB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;4BAC7B,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gCACzB,KAAK,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;6BACtB;iCAAM;gCACN,KAAK,qBAAQ,KAAK,CAAE,CAAC;6BACrB;4BACD,YAAY,GAAG,IAAI,KAAK,CAAC,KAAK,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC;4BACzD,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;4BACtC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;yBAC/B;6BAAM;4BACN,YAAY,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;yBACvC;wBAED,GAAG,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;wBAClB,OAAO,YAAY,CAAC;qBACpB;oBAED,GAAG,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;oBAClB,OAAO,KAAK,CAAC;gBACd,CAAC;gBAED,GAAG,CAAC,GAAQ,EAAE,IAAY,EAAE,KAAU;oBACrC,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC;oBAE7B,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAe,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;oBACpG,GAAG,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;oBAElB,OAAO,IAAI,CAAC;gBACb,CAAC;gBAED,cAAc,CAAC,GAAQ,EAAE,IAAY;oBACpC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAe,CAAC,CAAC,CAAC,CAAC;oBAC5F,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;oBAEjB,OAAO,IAAI,CAAC;gBACb,CAAC;aACD,CAAC,CAAC;YAEH,OAAO,EAAE,KAAK,EAAE,IAAI,KAAK,CAAC,EAAE,EAAE,aAAa,EAAE,CAAM,EAAE,UAAU,EAAE,eAAe,EAAE,CAAC;QACpF,CAAC;QAED,IAAI;YACH,OAAO,OAAO,EAAE;gBACf,IAAI,OAAO,GAAG,EAAE,CAAC;gBACjB,MAAM,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;gBAElE,OAAO,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,eAA8B,EAAE,EAAE;oBAC7D,IAAI,KAAQ,CAAC;oBACb,IAAI,eAAe,GAAqB,EAAE,CAAC;oBAC3C,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;wBACjC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,GAAG,WAAW,EAAE,CAAC;wBAC5C,KAAK,GAAG,KAAK,CAAC;wBACd,eAAe,GAAG,UAAU,CAAC;qBAC7B;oBACD,IAAI,MAAM,GAAG,eAAe,CAAC;wBAC5B,EAAE;wBACF,GAAG;wBACH,IAAI;wBACJ,OAAO;wBACP,IAAI,KAAK;4BACR,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;gCACjC,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC;6BAC5B;4BAED,OAAO,KAAK,CAAC;wBACd,CAAC;qBACD,CAAC,CAAC;oBAEH,IAAI,UAAU,CAAC,MAAM,CAAC,EAAE;wBACvB,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE;4BAC7B,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,eAAe,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC;4BAEzE,OAAO,MAAM,CAAC;wBACf,CAAC,CAAC,CAAC;qBACH;yBAAM;wBACN,MAAM;4BACL,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,eAAe,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC;wBAE1F,OAAO,MAAM,CAAC;qBACd;gBACF,CAAC,CAAC,CAAC;gBACH,IAAI,eAAmC,CAAC;gBACxC,IAAI,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;oBAC7B,eAAe,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;iBAC7C;qBAAM;oBACN,eAAe,GAAG,OAA6B,CAAC;iBAChD;gBAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACxC,UAAU,CAAC,IAAI,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvC,cAAc,GAAG,CAAC,GAAG,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,cAAc,CAAC,CAAC;iBACnE;gBAED,KAAK,CAAC,UAAU,EAAE,CAAC;gBACnB,OAAO,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;aAC/B;SACD;QAAC,OAAO,CAAC,EAAE;YACX,IAAI,CAAC,CAAC,OAAO,KAAK,UAAU,EAAE;gBAC7B,MAAM,CAAC,CAAC;aACR;YACD,KAAK,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC;SAC9B;QAED,KAAK;YACJ,KAAK,CAAC,KAAK,EAAE;gBACZ,cAAc;gBACd,KAAK;gBACL,EAAE;gBACF,UAAU;gBACV,KAAK;gBACL,EAAE;gBACF,GAAG;gBACH,IAAI;gBACJ,QAAQ;gBACR,OAAO;aACP,CAAC,CAAC;QACJ,OAAO,OAAO,CAAC,OAAO,CAAC;YACtB,KAAK;YACL,cAAc;YACd,EAAE;YACF,KAAK;YACL,UAAU;YACV,KAAK;YACL,EAAE;YACF,GAAG;YACH,IAAI;YACJ,QAAQ;YACR,OAAO;SACP,CAAC,CAAC;IACJ,CAAC,CAAC;AACH,CAAC;AACD;;;;;GAKG;AACH,MAAM,UAAU,aAAa,CAC5B,EAAU,EACV,QAAwB,EACxB,SAA+C;IAE/C,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAEhF,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM;QAChC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,YAAY,EAAE,EAAE;YAC5C,OAAO,gBAAgB,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC;QACpD,CAAC,CAAC;QACJ,CAAC,CAAC,SAAS,CAAC;IAEb,MAAM,EAAE,MAAM,GAAG,SAAS,EAAE,KAAK,GAAG,SAAS,EAAE,GAAG,QAAQ,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;IAE7E,UAAU,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;IAClD,OAAO,CAAC,KAAe,EAAE,WAA4B,EAAE,EAAE,CACxD,eAAe,CAAC,EAAE,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,WAAW,CAAC,CAAC;AACnE,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,wBAAwB,CAAC,SAA4B;IACpE,OAAO,CACN,EAAU,EACV,QAA6C,EAC7C,QAA6B,EACb,EAAE;QAClB,OAAO,aAAa,CAAC,EAAE,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;IACrF,CAAC,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,SAAS,gBAAgB,CAAC,eAAgC,EAAE,EAAU;IACrE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,eAAe,EAAE,CAAC;IAC5C,OAAO,CAAC,gBAAkC,EAAE,EAAE;QAC7C,MAAM,EAAE,MAAM,EAAE,cAAc,GAAG,SAAS,EAAE,KAAK,EAAE,aAAa,GAAG,SAAS,EAAE,GAAG,gBAAgB;YAChG,CAAC,CAAC,gBAAgB,EAAE;YACpB,CAAC,CAAC,EAAE,CAAC;QACN,OAAO,GAAG,EAAE,CAAC,CAAC;YACb,KAAK,CAAC,KAA0B,EAAE,MAAqB;gBACtD,IAAI,aAAa,EAAE;oBAClB,aAAa,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;iBAC7B;gBAED,IAAI,KAAK,EAAE;oBACV,KAAK,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;iBACrB;YACF,CAAC;YACD,MAAM,CAAC,OAAuB,EAAE,KAAiB;gBAChD,IAAI,cAAc,EAAE;oBACnB,cAAc,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;iBACnC;gBAED,IAAI,MAAM,EAAE;oBACX,MAAM,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;iBAC3B;YACF,CAAC;SACD,CAAC,CAAC;IACJ,CAAC,CAAC;AACH,CAAC;AAED,MAAM,UAAU,uBAAuB,CACtC,QAA8B;IAE9B,IAAI,GAAG,CAAC,YAAY,CAAC,EAAE;QACtB,OAAO,CAAC,IAAI,CACX,6KAA6K,CAC7K,CAAC;KACF;IACD,MAAM,iBAAiB,GAAG,GAAG,EAAE,CAAC,CAAC;QAChC,KAAK,EAAE,QAAQ;KACf,CAAC,CAAC;IACH,OAAO,CAAC,YAA+B,EAAE,EAAE,EAAE;QAC5C,OAAO,CAAC,iBAAiB,EAAE,GAAG,SAAS,CAAC,CAAC;IAC1C,CAAC,CAAC;AACH,CAAC","sourcesContent":["import { isThenable } from '../shim/Promise';\nimport { PatchOperation } from './state/Patch';\nimport { replace, remove } from './state/operations';\nimport { Path, State, Store } from './Store';\nimport Map from '../shim/Map';\nimport has from '../core/has';\n\n/**\n * Default Payload interface\n */\nexport interface DefaultPayload {\n\t[index: string]: any;\n}\n\n/**\n * The arguments passed to a `Command`\n */\nexport interface CommandRequest<T = any, P extends object = DefaultPayload> extends State<T> {\n\tpayload: P;\n\tstate: T;\n}\n\n/**\n * A command factory interface. Returns the passed command. This provides a way to automatically infer and/or\n * verify the type of multiple commands without explicitly specifying the generic for each command\n */\nexport interface CommandFactory<T = any, P extends object = DefaultPayload> {\n\t<R extends object = P>(command: AsyncCommandWithOps<T, R>): AsyncCommandWithOps<T, R>;\n\t<R extends object = P>(command: SyncCommandWithOps<T, R>): SyncCommandWithOps<T, R>;\n\t<R extends object = P>(command: AsyncCommand<T, R>): AsyncCommand<T, R>;\n\t<R extends object = P>(command: SyncCommand<T, R>): SyncCommand<T, R>;\n}\n\nexport interface AsyncCommandWithOps<T = any, P extends object = DefaultPayload> {\n\t(request: CommandRequest<T, P>): Promise<PatchOperation<T>[]>;\n}\n\nexport interface SyncCommandWithOps<T = any, P extends object = DefaultPayload> {\n\t(request: CommandRequest<T, P>): PatchOperation<T>[];\n}\n\nexport interface AsyncCommand<T = any, P extends object = DefaultPayload> {\n\t(request: CommandRequest<T, P>): Promise<void>;\n}\n\nexport interface SyncCommand<T = any, P extends object = DefaultPayload> {\n\t(request: CommandRequest<T, P>): void;\n}\n\n/**\n * Command that returns patch operations based on the command request\n */\nexport type Command<T = any, P extends object = DefaultPayload> =\n\t| SyncCommand<T, P>\n\t| AsyncCommand<T, P>\n\t| SyncCommandWithOps<T, P>\n\t| AsyncCommandWithOps<T, P>;\n\n/**\n * Transformer function\n */\nexport interface Transformer<P extends object = DefaultPayload, R extends object = DefaultPayload> {\n\t(payload: R): P;\n}\n\n/**\n * A process that returns an executor using a Store and Transformer\n */\nexport interface Process<T = any, P extends object = DefaultPayload> {\n\t<R extends object = DefaultPayload>(store: Store<T>, transformer: Transformer<P, R>): ProcessExecutor<T, P, R>;\n\t(store: Store<T>): ProcessExecutor<T, P, P>;\n}\n\n/**\n * Represents an error from a ProcessExecutor\n */\nexport interface ProcessError<T = any> {\n\terror: Error | null;\n\tcommand?: Command<T, any>[] | Command<T, any>;\n}\n\nexport interface ProcessResultExecutor<T = any> {\n\t<P extends object = DefaultPayload, R extends object = DefaultPayload>(\n\t\tprocess: Process<T, P>,\n\t\tpayload: R,\n\t\ttransformer: Transformer<P, R>\n\t): Promise<ProcessResult<T, P> | ProcessError<T>>;\n\t<P extends object = object>(process: Process<T, P>, payload: P): Promise<ProcessResult<T, P> | ProcessError<T>>;\n}\n\n/**\n * Represents a successful result from a ProcessExecutor\n */\nexport interface ProcessResult<T = any, P extends object = DefaultPayload> extends State<T> {\n\texecutor: ProcessResultExecutor<T>;\n\tstore: Store<T>;\n\toperations: PatchOperation<T>[];\n\tundoOperations: PatchOperation<T>[];\n\tapply: (operations: PatchOperation<T>[], invalidate?: boolean) => PatchOperation<T>[];\n\tpayload: P;\n\tid: string;\n\terror?: ProcessError<T> | null;\n}\n\n/**\n * Runs a process for the given arguments.\n */\nexport interface ProcessExecutor<T = any, P extends object = DefaultPayload, R extends object = DefaultPayload> {\n\t(payload: R): Promise<ProcessResult<T, P>>;\n}\n\nexport interface ProcessCallback<T = any, P extends object = DefaultPayload> {\n\t(): {\n\t\tbefore?: ProcessCallbackBefore<T, P>;\n\t\tafter?: ProcessCallbackAfter<T>;\n\t};\n}\n\n/**\n * Callback for a process, returns an error as the first argument\n */\nexport interface ProcessCallbackAfter<T = any> {\n\t(error: ProcessError<T> | null, result: ProcessResult<T>): void;\n}\n\nexport interface ProcessCallbackBefore<T = any, P extends object = DefaultPayload> {\n\t(payload: P, store: Store<T>, id: string): void | Promise<void>;\n}\n\n/**\n * Function for undoing operations\n */\nexport interface Undo {\n\t(): void;\n}\n\n/**\n * ProcessCallbackDecorator callback\n */\ninterface ProcessCallbackDecorator {\n\t(callback?: ProcessCallback): ProcessCallback;\n}\n\n/**\n * CreateProcess factory interface\n */\nexport interface CreateProcess<T = any, P extends object = DefaultPayload> {\n\t(id: string, commands: (Command<T, P>[] | Command<T, P>)[], callback?: ProcessCallback<T>): Process<T, P>;\n}\n\n/**\n * Creates a command factory with the specified type\n */\nexport function createCommandFactory<T, P extends object = DefaultPayload>(): CommandFactory<T, P> {\n\tfunction commandFactory<R extends object = P>(command: AsyncCommand<T, R>): AsyncCommand<T, R>;\n\tfunction commandFactory<R extends object = P>(command: SyncCommand<T, R>): SyncCommand<T, R>;\n\tfunction commandFactory<R extends object = P>(command: AsyncCommandWithOps<T, R>): AsyncCommandWithOps<T, R>;\n\tfunction commandFactory<R extends object = P>(command: SyncCommandWithOps<T, R>): SyncCommandWithOps<T, R>;\n\tfunction commandFactory<R extends object = P>(command: Command<T, R>): Command<T, R> {\n\t\treturn command;\n\t}\n\treturn commandFactory;\n}\n\n/**\n * Commands that can be passed to a process\n */\nexport type Commands<T = any, P extends object = DefaultPayload> = (Command<T, P>[] | Command<T, P>)[];\n\nconst processMap = new Map();\nconst valueSymbol = Symbol('value');\n\nexport function isStateProxy(value: any) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\treturn Boolean(value[valueSymbol]);\n}\n\nexport function getProcess(id: string) {\n\treturn processMap.get(id);\n}\n\nconst proxyError = 'State updates are not available on legacy browsers';\n\nfunction removeProxies(value: any) {\n\tif (typeof value === 'object' && value !== null) {\n\t\tif (value[valueSymbol]) {\n\t\t\tvalue = value[valueSymbol];\n\t\t}\n\n\t\tconst newValue: typeof value = Array.isArray(value) ? [] : {};\n\t\tconst keys = Object.keys(value);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tnewValue[keys[i]] = removeProxies(value[keys[i]]);\n\t\t}\n\n\t\tvalue = newValue;\n\t}\n\n\treturn value;\n}\n\nexport function processExecutor<T = any, P extends object = DefaultPayload>(\n\tid: string,\n\tcommands: Commands<T, P>,\n\tstore: Store<T>,\n\tbefore: ProcessCallbackBefore | undefined,\n\tafter: ProcessCallbackAfter | undefined,\n\ttransformer: Transformer<P> | undefined\n): ProcessExecutor<T, any, any> {\n\tconst { apply, get, path, at } = store;\n\tfunction executor(\n\t\tprocess: Process,\n\t\tpayload: any,\n\t\ttransformer?: Transformer\n\t): Promise<ProcessResult | ProcessError> {\n\t\treturn process(store)(payload);\n\t}\n\n\treturn async (executorPayload: P): Promise<ProcessResult<T, P>> => {\n\t\tconst operations: PatchOperation[] = [];\n\t\tconst commandsCopy = [...commands];\n\t\tlet undoOperations: PatchOperation[] = [];\n\t\tlet command = commandsCopy.shift();\n\t\tlet error: ProcessError | null = null;\n\t\tconst payload = transformer ? transformer(executorPayload) : executorPayload;\n\n\t\tif (before) {\n\t\t\tlet result = before(payload, store, id);\n\t\t\tif (result) {\n\t\t\t\tawait result;\n\t\t\t}\n\t\t}\n\n\t\tfunction createProxy() {\n\t\t\tconst proxies = new Map<string, any>();\n\t\t\tconst proxied = new Map<string, any>();\n\n\t\t\tconst proxyOperations: PatchOperation[] = [];\n\t\t\tconst createHandler = (partialPath?: Path<T, any>) => ({\n\t\t\t\tget(obj: any, prop: string): any {\n\t\t\t\t\tconst fullPath = partialPath ? path(partialPath, prop) : path(prop as keyof T);\n\t\t\t\t\tconst stringPath = fullPath.path;\n\n\t\t\t\t\tif (typeof prop === 'symbol' && prop === valueSymbol) {\n\t\t\t\t\t\treturn proxied.get(stringPath);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet value = partialPath || obj.hasOwnProperty(prop) ? obj[prop] : get(fullPath);\n\n\t\t\t\t\tif (typeof value === 'object' && value !== null) {\n\t\t\t\t\t\tlet proxiedValue;\n\t\t\t\t\t\tif (!proxies.has(stringPath)) {\n\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\tvalue = value.slice();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvalue = { ...value };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tproxiedValue = new Proxy(value, createHandler(fullPath));\n\t\t\t\t\t\t\tproxies.set(stringPath, proxiedValue);\n\t\t\t\t\t\t\tproxied.set(stringPath, value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tproxiedValue = proxies.get(stringPath);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobj[prop] = value;\n\t\t\t\t\t\treturn proxiedValue;\n\t\t\t\t\t}\n\n\t\t\t\t\tobj[prop] = value;\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tset(obj: any, prop: string, value: any) {\n\t\t\t\t\tvalue = removeProxies(value);\n\n\t\t\t\t\tproxyOperations.push(replace(partialPath ? path(partialPath, prop) : path(prop as keyof T), value));\n\t\t\t\t\tobj[prop] = value;\n\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\tdeleteProperty(obj: any, prop: string) {\n\t\t\t\t\tproxyOperations.push(remove(partialPath ? path(partialPath, prop) : path(prop as keyof T)));\n\t\t\t\t\tdelete obj[prop];\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn { proxy: new Proxy({}, createHandler()) as T, operations: proxyOperations };\n\t\t}\n\n\t\ttry {\n\t\t\twhile (command) {\n\t\t\t\tlet results = [];\n\t\t\t\tconst commandArray = Array.isArray(command) ? command : [command];\n\n\t\t\t\tresults = commandArray.map((commandFunction: Command<T, P>) => {\n\t\t\t\t\tlet state: T;\n\t\t\t\t\tlet proxyOperations: PatchOperation[] = [];\n\t\t\t\t\tif (typeof Proxy !== 'undefined') {\n\t\t\t\t\t\tconst { operations, proxy } = createProxy();\n\t\t\t\t\t\tstate = proxy;\n\t\t\t\t\t\tproxyOperations = operations;\n\t\t\t\t\t}\n\t\t\t\t\tlet result = commandFunction({\n\t\t\t\t\t\tat,\n\t\t\t\t\t\tget,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tpayload,\n\t\t\t\t\t\tget state() {\n\t\t\t\t\t\t\tif (typeof Proxy === 'undefined') {\n\t\t\t\t\t\t\t\tthrow new Error(proxyError);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn state;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t\treturn result.then((result) => {\n\t\t\t\t\t\t\tresult = result ? [...proxyOperations, ...result] : [...proxyOperations];\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult =\n\t\t\t\t\t\t\tresult && Array.isArray(result) ? [...proxyOperations, ...result] : [...proxyOperations];\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlet resolvedResults: PatchOperation[][];\n\t\t\t\tif (results.some(isThenable)) {\n\t\t\t\t\tresolvedResults = await Promise.all(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolvedResults = results as PatchOperation[][];\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\toperations.push(...resolvedResults[i]);\n\t\t\t\t\tundoOperations = [...apply(resolvedResults[i]), ...undoOperations];\n\t\t\t\t}\n\n\t\t\t\tstore.invalidate();\n\t\t\t\tcommand = commandsCopy.shift();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e.message === proxyError) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\terror = { error: e, command };\n\t\t}\n\n\t\tafter &&\n\t\t\tafter(error, {\n\t\t\t\tundoOperations,\n\t\t\t\tstore,\n\t\t\t\tid,\n\t\t\t\toperations,\n\t\t\t\tapply,\n\t\t\t\tat,\n\t\t\t\tget,\n\t\t\t\tpath,\n\t\t\t\texecutor,\n\t\t\t\tpayload\n\t\t\t});\n\t\treturn Promise.resolve({\n\t\t\tstore,\n\t\t\tundoOperations,\n\t\t\tid,\n\t\t\terror,\n\t\t\toperations,\n\t\t\tapply,\n\t\t\tat,\n\t\t\tget,\n\t\t\tpath,\n\t\t\texecutor,\n\t\t\tpayload\n\t\t});\n\t};\n}\n/**\n * Factories a process using the provided commands and an optional callback. Returns an executor used to run the process.\n *\n * @param commands The commands for the process\n * @param callback Callback called after the process is completed\n */\nexport function createProcess<T = any, P extends object = DefaultPayload>(\n\tid: string,\n\tcommands: Commands<T, P>,\n\tcallbacks?: ProcessCallback | ProcessCallback[]\n): Process<T, P> {\n\tcallbacks = Array.isArray(callbacks) ? callbacks : callbacks ? [callbacks] : [];\n\n\tconst callback = callbacks.length\n\t\t? callbacks.reduce((callback, nextCallback) => {\n\t\t\t\treturn combineCallbacks(nextCallback, id)(callback);\n\t\t  })\n\t\t: undefined;\n\n\tconst { before = undefined, after = undefined } = callback ? callback() : {};\n\n\tprocessMap.set(id, [id, commands, before, after]);\n\treturn (store: Store<T>, transformer?: Transformer<P>) =>\n\t\tprocessExecutor(id, commands, store, before, after, transformer);\n}\n\n/**\n * Creates a process factory that will create processes with the specified callback decorators applied.\n * @param callbacks array of process callback to be used by the returned factory.\n * @param initializers array of process initializers to be used by the returned factory.\n */\nexport function createProcessFactoryWith(callbacks: ProcessCallback[]) {\n\treturn <S, P extends object>(\n\t\tid: string,\n\t\tcommands: (Command<S, P>[] | Command<S, P>)[],\n\t\tcallback?: ProcessCallback<S>\n\t): Process<S, P> => {\n\t\treturn createProcess(id, commands, callback ? [...callbacks, callback] : callbacks);\n\t};\n}\n\n/**\n * Creates a `ProcessCallbackDecorator` from a `ProcessCallback`.\n * @param processCallback the process callback to convert to a decorator.\n * @param id process id to be passed to the before callback\n */\nfunction combineCallbacks(processCallback: ProcessCallback, id: string): ProcessCallbackDecorator {\n\tconst { before, after } = processCallback();\n\treturn (previousCallback?: ProcessCallback) => {\n\t\tconst { before: previousBefore = undefined, after: previousAfter = undefined } = previousCallback\n\t\t\t? previousCallback()\n\t\t\t: {};\n\t\treturn () => ({\n\t\t\tafter(error: ProcessError | null, result: ProcessResult) {\n\t\t\t\tif (previousAfter) {\n\t\t\t\t\tpreviousAfter(error, result);\n\t\t\t\t}\n\n\t\t\t\tif (after) {\n\t\t\t\t\tafter(error, result);\n\t\t\t\t}\n\t\t\t},\n\t\t\tbefore(payload: DefaultPayload, store: Store<any>) {\n\t\t\t\tif (previousBefore) {\n\t\t\t\t\tpreviousBefore(payload, store, id);\n\t\t\t\t}\n\n\t\t\t\tif (before) {\n\t\t\t\t\tbefore(payload, store, id);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n}\n\nexport function createCallbackDecorator(\n\tcallback: ProcessCallbackAfter\n): (callbacks?: ProcessCallback[]) => ProcessCallback[] {\n\tif (has('dojo-debug')) {\n\t\tconsole.warn(\n\t\t\t'Process using the the legacy middleware API. Please update to use the latest API, see https://github.com/dojo/framework/blob/master/docs/V5-Migration-Guide.md for details.'\n\t\t);\n\t}\n\tconst convertedCallback = () => ({\n\t\tafter: callback\n\t});\n\treturn (callbacks: ProcessCallback[] = []) => {\n\t\treturn [convertedCallback, ...callbacks];\n\t};\n}\n"]}