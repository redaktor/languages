(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "./Patch", "./Pointer", "immutable", "./compare"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var Patch_1 = require("./Patch");
    var Pointer_1 = require("./Pointer");
    var immutable_1 = require("immutable");
    var compare_1 = require("./compare");
    function isString(segment) {
        return typeof segment === 'string';
    }
    function isList(value) {
        return Boolean(value && immutable_1.List.isList(value));
    }
    function isMap(value) {
        return Boolean(value && immutable_1.Map.isMap(value));
    }
    function inverse(operation, state) {
        if (operation.op === Patch_1.OperationType.ADD) {
            var op = {
                op: Patch_1.OperationType.REMOVE,
                path: operation.path
            };
            var test = {
                op: Patch_1.OperationType.TEST,
                path: operation.path,
                value: operation.value
            };
            return [test, op];
        }
        else if (operation.op === Patch_1.OperationType.REPLACE) {
            var value = state.getIn(operation.path.segments);
            var op = void 0;
            if (value === undefined) {
                op = {
                    op: Patch_1.OperationType.REMOVE,
                    path: operation.path
                };
            }
            else {
                op = {
                    op: Patch_1.OperationType.REPLACE,
                    path: operation.path,
                    value: state.getIn(operation.path.segments)
                };
            }
            var test = {
                op: Patch_1.OperationType.TEST,
                path: operation.path,
                value: operation.value
            };
            return [test, op];
        }
        else {
            return [
                {
                    op: Patch_1.OperationType.ADD,
                    path: operation.path,
                    value: state.getIn(operation.path.segments)
                }
            ];
        }
    }
    var ImmutableState = /** @class */ (function () {
        function ImmutableState() {
            var _this = this;
            this._state = immutable_1.Map();
            /**
             * Returns the state at a specific pointer path location.
             */
            this.get = function (path) {
                return path.value;
            };
            this.at = function (path, index) {
                var array = _this.get(path);
                var value = array && array[index];
                return {
                    path: path.path + "/" + index,
                    state: path.state,
                    value: value
                };
            };
            this.path = function (path) {
                var segments = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    segments[_i - 1] = arguments[_i];
                }
                if (typeof path === 'string') {
                    segments = tslib_1.__spread([path], segments);
                }
                else {
                    segments = tslib_1.__spread(new Pointer_1.Pointer(path.path).segments, segments);
                }
                var stringSegments = segments.filter(isString);
                var hasMultipleSegments = stringSegments.length > 1;
                var pointer = new Pointer_1.Pointer(hasMultipleSegments ? stringSegments : stringSegments[0] || '');
                var value = _this._state.getIn(pointer.segments);
                if (pointer.segments.length > 1 && pointer.segments[pointer.segments.length - 1] === 'length') {
                    var parent_1 = pointer.segments.slice(0, pointer.segments.length - 1);
                    var parentState = _this._state.getIn(parent_1);
                    if (isList(parentState)) {
                        value = parentState.size;
                    }
                }
                if (isList(value) || isMap(value)) {
                    value = value.toJS();
                }
                return {
                    path: pointer.path,
                    state: _this._state,
                    value: value
                };
            };
        }
        ImmutableState.prototype.apply = function (operations) {
            var _this = this;
            var undoOperations = [];
            var patchedState = operations.reduce(function (state, next) {
                var patchedState;
                switch (next.op) {
                    case Patch_1.OperationType.ADD:
                        patchedState = _this.setIn(next.path.segments, next.value, state, true);
                        break;
                    case Patch_1.OperationType.REPLACE:
                        patchedState = _this.setIn(next.path.segments, next.value, state);
                        break;
                    case Patch_1.OperationType.REMOVE:
                        patchedState = state.removeIn(next.path.segments);
                        break;
                    case Patch_1.OperationType.TEST:
                        var current = state.getIn(next.path.segments);
                        var currentValue = current && current.toJS ? current.toJS() : current;
                        if (!compare_1.isEqual(currentValue, next.value)) {
                            var location_1 = next.path.path;
                            throw new Error("Test operation failure at \"" + location_1 + "\". " + compare_1.getFriendlyDifferenceMessage(next.value, currentValue) + ".");
                        }
                        return state;
                    default:
                        throw new Error('Unknown operation');
                }
                undoOperations = tslib_1.__spread(inverse(next, state), undoOperations);
                return patchedState;
            }, this._state);
            this._state = patchedState;
            return undoOperations;
        };
        ImmutableState.prototype.setIn = function (segments, value, state, add) {
            if (add === void 0) { add = false; }
            var updated = this.set(segments, value, state, add);
            if (updated) {
                return updated;
            }
            state = state.withMutations(function (map) {
                segments.slice(0, segments.length - 1).forEach(function (segment, index) {
                    var nextSegment = '';
                    if (index + 1 < segments.length) {
                        nextSegment = segments[index + 1];
                    }
                    var value = state.getIn(tslib_1.__spread(segments.slice(0, index), [segment]));
                    if (!value || !(value instanceof immutable_1.List || value instanceof immutable_1.Map)) {
                        if (!isNaN(nextSegment) && !isNaN(parseInt(nextSegment, 0))) {
                            map = map.setIn(tslib_1.__spread(segments.slice(0, index), [segment]), immutable_1.List());
                        }
                        else {
                            map = map.setIn(tslib_1.__spread(segments.slice(0, index), [segment]), immutable_1.Map());
                        }
                    }
                });
            });
            return this.set(segments, value, state, add) || state;
        };
        ImmutableState.prototype.set = function (segments, value, state, add) {
            if (add === void 0) { add = false; }
            if (typeof value === 'object' && value != null) {
                if (Array.isArray(value)) {
                    value = immutable_1.List(value);
                }
                else {
                    value = immutable_1.Map(value);
                }
            }
            segments = segments.slice();
            var allSegments = segments.slice();
            var lastSegment = segments.pop();
            var parent = state.getIn(segments);
            if (isList(parent) && add) {
                state = state.setIn(segments, parent.insert(lastSegment, value));
                return state;
            }
            else if (isList(parent) || isMap(parent)) {
                state = state.setIn(allSegments, value);
                return state;
            }
            return false;
        };
        return ImmutableState;
    }());
    exports.ImmutableState = ImmutableState;
});
//# sourceMappingURL=ImmutableState.js.map