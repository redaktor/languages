(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "./support/selector", "../core/vdom", "../core/util", "../core/WidgetBase"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var selector_1 = require("./support/selector");
    var vdom_1 = require("../core/vdom");
    var util_1 = require("../core/util");
    var WidgetBase_1 = require("../core/WidgetBase");
    var findOne = function (nodes, selector) {
        var _a;
        var finalSelector = selector;
        if (selector.indexOf('~') === 0) {
            finalSelector = "[\\~key='" + selector.substr(1) + "']";
        }
        var _b = tslib_1.__read(selector_1.default(finalSelector, nodes), 1), node = _b[0];
        if (!node) {
            finalSelector = "[assertion-key='" + selector.substr(1) + "']";
            _a = tslib_1.__read(selector_1.default(finalSelector, nodes), 1), node = _a[0];
        }
        if (!node) {
            throw Error("Node not found for selector \"" + selector + "\"");
        }
        if (!vdom_1.isWNode(node) && !vdom_1.isVNode(node)) {
            throw Error('Cannot set or get on unknown node');
        }
        return node;
    };
    var replaceChildren = function (selector, render, modifyChildrenFn) {
        var node = findOne(render, selector);
        var parent = node.parent;
        var siblings = parent ? parent.children : Array.isArray(render) ? render : [render];
        var newChildren = modifyChildrenFn(siblings.indexOf(node), tslib_1.__spread(siblings));
        if (!parent) {
            return newChildren;
        }
        parent.children = newChildren;
        return render;
    };
    var Ignore = /** @class */ (function (_super) {
        tslib_1.__extends(Ignore, _super);
        function Ignore() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Ignore;
    }(WidgetBase_1.default));
    exports.Ignore = Ignore;
    function assertionTemplate(renderFunc) {
        var assertionTemplateResult = function () {
            var render = renderFunc();
            util_1.decorate(render, function (node) {
                if (vdom_1.isWNode(node) || vdom_1.isVNode(node)) {
                    delete node.properties['~key'];
                    delete node.properties['assertion-key'];
                }
            });
            return render;
        };
        assertionTemplateResult.setProperty = function (selector, property, value) {
            return assertionTemplate(function () {
                var render = renderFunc();
                var node = findOne(render, selector);
                node.properties[property] = value;
                return render;
            });
        };
        assertionTemplateResult.setProperties = function (selector, value) {
            return assertionTemplate(function () {
                var render = renderFunc();
                var node = findOne(render, selector);
                node.properties = value;
                return render;
            });
        };
        assertionTemplateResult.append = function (selector, children) {
            return assertionTemplateResult.setChildren(selector, children, 'append');
        };
        assertionTemplateResult.prepend = function (selector, children) {
            return assertionTemplateResult.setChildren(selector, children, 'prepend');
        };
        assertionTemplateResult.replaceChildren = function (selector, children) {
            return assertionTemplateResult.setChildren(selector, children, 'replace');
        };
        assertionTemplateResult.setChildren = function (selector, children, type) {
            if (type === void 0) { type = 'replace'; }
            if (Array.isArray(children)) {
                console.warn('The array API (`children: DNode[]`) has been deprecated. Working with children should use a factory to avoid issues with mutation.');
            }
            return assertionTemplate(function () {
                var render = renderFunc();
                var node = findOne(render, selector);
                node.children = node.children || [];
                if (typeof children === 'function') {
                    children = children();
                }
                switch (type) {
                    case 'prepend':
                        node.children = tslib_1.__spread(children, node.children);
                        break;
                    case 'append':
                        node.children = tslib_1.__spread(node.children, children);
                        break;
                    case 'replace':
                        node.children = tslib_1.__spread(children);
                        break;
                }
                return render;
            });
        };
        assertionTemplateResult.insertBefore = function (selector, children) {
            return assertionTemplateResult.insertSiblings(selector, children, 'before');
        };
        assertionTemplateResult.insertAfter = function (selector, children) {
            return assertionTemplateResult.insertSiblings(selector, children, 'after');
        };
        assertionTemplateResult.insertSiblings = function (selector, children, type) {
            if (type === void 0) { type = 'after'; }
            if (Array.isArray(children)) {
                console.warn('The array API (`children: DNode[]`) has been deprecated. Working with children should use a factory to avoid issues with mutation.');
            }
            return assertionTemplate(function () {
                var render = renderFunc();
                var insertedChildren = typeof children === 'function' ? (children = children()) : children;
                return replaceChildren(selector, render, function (index, children) {
                    if (type === 'after') {
                        children.splice.apply(children, tslib_1.__spread([index + 1, 0], insertedChildren));
                    }
                    else {
                        children.splice.apply(children, tslib_1.__spread([index, 0], insertedChildren));
                    }
                    return children;
                });
            });
        };
        assertionTemplateResult.getProperty = function (selector, property) {
            var render = renderFunc();
            var node = findOne(render, selector);
            return node.properties[property];
        };
        assertionTemplateResult.getProperties = function (selector, property) {
            var render = renderFunc();
            var node = findOne(render, selector);
            return node.properties;
        };
        assertionTemplateResult.getChildren = function (selector) {
            var render = renderFunc();
            var node = findOne(render, selector);
            return node.children || [];
        };
        assertionTemplateResult.replace = function (selector, newNode) {
            return assertionTemplate(function () {
                var render = renderFunc();
                return replaceChildren(selector, render, function (index, children) {
                    children.splice(index, 1, newNode);
                    return children;
                });
            });
        };
        assertionTemplateResult.remove = function (selector) {
            return assertionTemplate(function () {
                var render = renderFunc();
                return replaceChildren(selector, render, function (index, children) {
                    children.splice(index, 1);
                    return children;
                });
            });
        };
        return assertionTemplateResult;
    }
    exports.assertionTemplate = assertionTemplate;
    exports.default = assertionTemplate;
});
//# sourceMappingURL=assertionTemplate.js.map