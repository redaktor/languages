import select from './support/selector';
import { isWNode, isVNode } from '../core/vdom';
import { decorate } from '../core/util';
import WidgetBase from '../core/WidgetBase';
const findOne = (nodes, selector) => {
    let finalSelector = selector;
    if (selector.indexOf('~') === 0) {
        finalSelector = `[\\~key='${selector.substr(1)}']`;
    }
    let [node] = select(finalSelector, nodes);
    if (!node) {
        finalSelector = `[assertion-key='${selector.substr(1)}']`;
        [node] = select(finalSelector, nodes);
    }
    if (!node) {
        throw Error(`Node not found for selector "${selector}"`);
    }
    if (!isWNode(node) && !isVNode(node)) {
        throw Error('Cannot set or get on unknown node');
    }
    return node;
};
const replaceChildren = (selector, render, modifyChildrenFn) => {
    const node = findOne(render, selector);
    const parent = node.parent;
    const siblings = parent ? parent.children : Array.isArray(render) ? render : [render];
    const newChildren = modifyChildrenFn(siblings.indexOf(node), [...siblings]);
    if (!parent) {
        return newChildren;
    }
    parent.children = newChildren;
    return render;
};
export class Ignore extends WidgetBase {
}
export function assertionTemplate(renderFunc) {
    const assertionTemplateResult = () => {
        const render = renderFunc();
        decorate(render, (node) => {
            if (isWNode(node) || isVNode(node)) {
                delete node.properties['~key'];
                delete node.properties['assertion-key'];
            }
        });
        return render;
    };
    assertionTemplateResult.setProperty = (selector, property, value) => {
        return assertionTemplate(() => {
            const render = renderFunc();
            const node = findOne(render, selector);
            node.properties[property] = value;
            return render;
        });
    };
    assertionTemplateResult.setProperties = (selector, value) => {
        return assertionTemplate(() => {
            const render = renderFunc();
            const node = findOne(render, selector);
            node.properties = value;
            return render;
        });
    };
    assertionTemplateResult.append = (selector, children) => {
        return assertionTemplateResult.setChildren(selector, children, 'append');
    };
    assertionTemplateResult.prepend = (selector, children) => {
        return assertionTemplateResult.setChildren(selector, children, 'prepend');
    };
    assertionTemplateResult.replaceChildren = (selector, children) => {
        return assertionTemplateResult.setChildren(selector, children, 'replace');
    };
    assertionTemplateResult.setChildren = (selector, children, type = 'replace') => {
        if (Array.isArray(children)) {
            console.warn('The array API (`children: DNode[]`) has been deprecated. Working with children should use a factory to avoid issues with mutation.');
        }
        return assertionTemplate(() => {
            const render = renderFunc();
            const node = findOne(render, selector);
            node.children = node.children || [];
            if (typeof children === 'function') {
                children = children();
            }
            switch (type) {
                case 'prepend':
                    node.children = [...children, ...node.children];
                    break;
                case 'append':
                    node.children = [...node.children, ...children];
                    break;
                case 'replace':
                    node.children = [...children];
                    break;
            }
            return render;
        });
    };
    assertionTemplateResult.insertBefore = (selector, children) => {
        return assertionTemplateResult.insertSiblings(selector, children, 'before');
    };
    assertionTemplateResult.insertAfter = (selector, children) => {
        return assertionTemplateResult.insertSiblings(selector, children, 'after');
    };
    assertionTemplateResult.insertSiblings = (selector, children, type = 'after') => {
        if (Array.isArray(children)) {
            console.warn('The array API (`children: DNode[]`) has been deprecated. Working with children should use a factory to avoid issues with mutation.');
        }
        return assertionTemplate(() => {
            const render = renderFunc();
            const insertedChildren = typeof children === 'function' ? (children = children()) : children;
            return replaceChildren(selector, render, (index, children) => {
                if (type === 'after') {
                    children.splice(index + 1, 0, ...insertedChildren);
                }
                else {
                    children.splice(index, 0, ...insertedChildren);
                }
                return children;
            });
        });
    };
    assertionTemplateResult.getProperty = (selector, property) => {
        const render = renderFunc();
        const node = findOne(render, selector);
        return node.properties[property];
    };
    assertionTemplateResult.getProperties = (selector, property) => {
        const render = renderFunc();
        const node = findOne(render, selector);
        return node.properties;
    };
    assertionTemplateResult.getChildren = (selector) => {
        const render = renderFunc();
        const node = findOne(render, selector);
        return node.children || [];
    };
    assertionTemplateResult.replace = (selector, newNode) => {
        return assertionTemplate(() => {
            const render = renderFunc();
            return replaceChildren(selector, render, (index, children) => {
                children.splice(index, 1, newNode);
                return children;
            });
        });
    };
    assertionTemplateResult.remove = (selector) => {
        return assertionTemplate(() => {
            const render = renderFunc();
            return replaceChildren(selector, render, (index, children) => {
                children.splice(index, 1);
                return children;
            });
        });
    };
    return assertionTemplateResult;
}
export default assertionTemplate;
//# sourceMappingURL=assertionTemplate.mjs.map