(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "./support/assertRender", "./support/selector", "../core/Registry", "../core/vdom"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var assertRender_1 = require("./support/assertRender");
    var selector_1 = require("./support/selector");
    var Registry_1 = require("../core/Registry");
    var vdom_1 = require("../core/vdom");
    var middlewareId = 0;
    var factory = vdom_1.create();
    function harness(renderFunc, options) {
        if (options === void 0) { options = []; }
        var invalidated = true;
        var wNode = renderFunc();
        var renderStack = [];
        var widget;
        var middleware = {};
        var properties = {};
        var children = [];
        var customDiffs = [];
        var customDiffNames = [];
        var customComparator = [];
        var mockMiddleware = [];
        if (Array.isArray(options)) {
            customComparator = options;
        }
        else {
            if (options.middleware) {
                mockMiddleware = options.middleware;
            }
            if (options.customComparator) {
                customComparator = options.customComparator;
            }
        }
        if (Registry_1.isWidgetFunction(wNode.widgetConstructor)) {
            widget = wNode.widgetConstructor;
            var resolveMiddleware_1 = function (middlewares, mocks) {
                var keys = Object.keys(middlewares);
                var results = {};
                var uniqueId = "" + middlewareId++;
                var mockMiddlewareMap = new Map(mocks);
                for (var i = 0; i < keys.length; i++) {
                    var isMock = false;
                    var middleware_1 = middlewares[keys[i]]();
                    if (mockMiddlewareMap.has(middlewares[keys[i]])) {
                        middleware_1 = mockMiddlewareMap.get(middlewares[keys[i]]);
                        isMock = true;
                    }
                    var payload = {
                        id: uniqueId,
                        properties: function () {
                            return tslib_1.__assign({}, properties);
                        },
                        children: function () {
                            return children;
                        }
                    };
                    if (middleware_1.middlewares) {
                        var resolvedMiddleware = resolveMiddleware_1(middleware_1.middlewares, mocks);
                        payload.middleware = resolvedMiddleware;
                        results[keys[i]] = middleware_1.callback(payload);
                    }
                    else {
                        if (isMock) {
                            var result = middleware_1();
                            var resolvedMiddleware = resolveMiddleware_1(result.middlewares, mocks);
                            payload.middleware = resolvedMiddleware;
                            results[keys[i]] = result.callback(payload);
                        }
                        else {
                            results[keys[i]] = middleware_1.callback(payload);
                        }
                    }
                }
                return results;
            };
            mockMiddleware.push([
                vdom_1.invalidator,
                factory(function () { return function () {
                    invalidated = true;
                }; })
            ]);
            mockMiddleware.push([vdom_1.destroy, factory(function () { return function () { }; })]);
            mockMiddleware.push([
                vdom_1.diffProperty,
                factory(function () { return function (propName, func) {
                    if (customDiffNames.indexOf(propName) === -1) {
                        customDiffNames.push(propName);
                        customDiffs.push(func);
                    }
                }; })
            ]);
            middleware = resolveMiddleware_1(wNode.widgetConstructor.middlewares, mockMiddleware);
        }
        else {
            var widgetConstructor = wNode.widgetConstructor;
            if (typeof widgetConstructor === 'function') {
                widget = new /** @class */ (function (_super) {
                    tslib_1.__extends(class_1, _super);
                    function class_1() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    class_1.prototype.invalidate = function () {
                        invalidated = true;
                        _super.prototype.invalidate.call(this);
                    };
                    return class_1;
                }(widgetConstructor))();
                _tryRender();
            }
            else {
                throw new Error('Harness does not support registry items');
            }
        }
        function _getRender(count) {
            return count ? renderStack[count] : renderStack[renderStack.length - 1];
        }
        function _runCompares(nodes, isExpected) {
            if (isExpected === void 0) { isExpected = false; }
            customComparator.forEach(function (_a) {
                var selector = _a.selector, property = _a.property, comparator = _a.comparator;
                var items = selector_1.select(selector, nodes);
                items.forEach(function (item) {
                    var comparatorName = "comparator(selector=" + selector + ", " + property + ")";
                    if (item && item.properties && item.properties[property] !== undefined) {
                        var comparatorResult = comparator(item.properties[property])
                            ? comparatorName
                            : comparatorName + " FAILED";
                        item.properties[property] = isExpected ? comparatorName : comparatorResult;
                    }
                });
            });
        }
        function _tryRender() {
            var render;
            var wNode = renderFunc();
            if (Registry_1.isWidgetFunction(widget)) {
                customDiffs.forEach(function (diff) { return diff(properties, wNode.properties); });
                vdom_1.propertiesDiff(properties, wNode.properties, function () {
                    invalidated = true;
                }, tslib_1.__spread(customDiffNames));
                if (children.length || wNode.children.length) {
                    invalidated = true;
                }
                properties = tslib_1.__assign({}, wNode.properties);
                children = wNode.children;
                if (invalidated) {
                    render = widget({ id: 'test', middleware: middleware, properties: function () { return properties; }, children: function () { return children; } });
                }
            }
            else {
                widget.__setProperties__(wNode.properties);
                widget.__setChildren__(wNode.children);
                if (invalidated) {
                    render = widget.__render__();
                }
            }
            if (invalidated) {
                var _a = selector_1.decorateNodes(render), hasDeferredProperties = _a.hasDeferredProperties, nodes = _a.nodes;
                _runCompares(nodes);
                renderStack.push(nodes);
                if (hasDeferredProperties) {
                    var afterDeferredPropertiesNodes = selector_1.decorateNodes(render).nodes;
                    _runCompares(afterDeferredPropertiesNodes);
                    renderStack.push(afterDeferredPropertiesNodes);
                }
                invalidated = false;
            }
        }
        function _expect(expectedRenderFunc, actualRenderFunc, selector) {
            var renderResult;
            if (actualRenderFunc === undefined) {
                _tryRender();
                renderResult = _getRender();
            }
            else {
                renderResult = actualRenderFunc();
            }
            var expectedRenderResult = selector_1.decorateNodes(expectedRenderFunc()).nodes;
            _runCompares(expectedRenderResult, true);
            if (selector) {
                var _a = tslib_1.__read(selector_1.select(selector, renderResult), 1), firstItem = _a[0];
                assertRender_1.default(firstItem, expectedRenderResult);
            }
            else {
                assertRender_1.default(renderResult, expectedRenderResult);
            }
        }
        return {
            expect: function (expectedRenderFunc, actualRenderFunc) {
                return _expect(expectedRenderFunc, actualRenderFunc);
            },
            expectPartial: function (selector, expectedRenderFunc, actualRenderFunc) {
                return _expect(expectedRenderFunc, actualRenderFunc, selector);
            },
            trigger: function (selector, functionSelector) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                _tryRender();
                var _a = tslib_1.__read(selector_1.select(selector, _getRender()), 1), firstItem = _a[0];
                if (!firstItem) {
                    throw new Error("Cannot find node with selector " + selector);
                }
                var triggerFunction;
                if (typeof functionSelector === 'string') {
                    triggerFunction = firstItem.properties[functionSelector];
                }
                else {
                    triggerFunction = functionSelector(firstItem);
                }
                if (triggerFunction) {
                    return triggerFunction.apply(widget, args);
                }
            },
            getRender: function (index) {
                return _getRender(index);
            }
        };
    }
    exports.harness = harness;
    exports.default = harness;
});
//# sourceMappingURL=harness.js.map