import assertRender from './support/assertRender';
import { decorateNodes, select } from './support/selector';
import { isWidgetFunction } from '../core/Registry';
import { invalidator, diffProperty, destroy, create, propertiesDiff } from '../core/vdom';
let middlewareId = 0;
const factory = create();
export function harness(renderFunc, options = []) {
    let invalidated = true;
    let wNode = renderFunc();
    const renderStack = [];
    let widget;
    let middleware = {};
    let properties = {};
    let children = [];
    let customDiffs = [];
    let customDiffNames = [];
    let customComparator = [];
    let mockMiddleware = [];
    if (Array.isArray(options)) {
        customComparator = options;
    }
    else {
        if (options.middleware) {
            mockMiddleware = options.middleware;
        }
        if (options.customComparator) {
            customComparator = options.customComparator;
        }
    }
    if (isWidgetFunction(wNode.widgetConstructor)) {
        widget = wNode.widgetConstructor;
        const resolveMiddleware = (middlewares, mocks) => {
            const keys = Object.keys(middlewares);
            const results = {};
            const uniqueId = `${middlewareId++}`;
            const mockMiddlewareMap = new Map(mocks);
            for (let i = 0; i < keys.length; i++) {
                let isMock = false;
                let middleware = middlewares[keys[i]]();
                if (mockMiddlewareMap.has(middlewares[keys[i]])) {
                    middleware = mockMiddlewareMap.get(middlewares[keys[i]]);
                    isMock = true;
                }
                const payload = {
                    id: uniqueId,
                    properties: () => {
                        return Object.assign({}, properties);
                    },
                    children: () => {
                        return children;
                    }
                };
                if (middleware.middlewares) {
                    const resolvedMiddleware = resolveMiddleware(middleware.middlewares, mocks);
                    payload.middleware = resolvedMiddleware;
                    results[keys[i]] = middleware.callback(payload);
                }
                else {
                    if (isMock) {
                        let result = middleware();
                        const resolvedMiddleware = resolveMiddleware(result.middlewares, mocks);
                        payload.middleware = resolvedMiddleware;
                        results[keys[i]] = result.callback(payload);
                    }
                    else {
                        results[keys[i]] = middleware.callback(payload);
                    }
                }
            }
            return results;
        };
        mockMiddleware.push([
            invalidator,
            factory(() => () => {
                invalidated = true;
            })
        ]);
        mockMiddleware.push([destroy, factory(() => () => { })]);
        mockMiddleware.push([
            diffProperty,
            factory(() => (propName, func) => {
                if (customDiffNames.indexOf(propName) === -1) {
                    customDiffNames.push(propName);
                    customDiffs.push(func);
                }
            })
        ]);
        middleware = resolveMiddleware(wNode.widgetConstructor.middlewares, mockMiddleware);
    }
    else {
        const widgetConstructor = wNode.widgetConstructor;
        if (typeof widgetConstructor === 'function') {
            widget = new class extends widgetConstructor {
                invalidate() {
                    invalidated = true;
                    super.invalidate();
                }
            }();
            _tryRender();
        }
        else {
            throw new Error('Harness does not support registry items');
        }
    }
    function _getRender(count) {
        return count ? renderStack[count] : renderStack[renderStack.length - 1];
    }
    function _runCompares(nodes, isExpected = false) {
        customComparator.forEach(({ selector, property, comparator }) => {
            const items = select(selector, nodes);
            items.forEach((item) => {
                const comparatorName = `comparator(selector=${selector}, ${property})`;
                if (item && item.properties && item.properties[property] !== undefined) {
                    const comparatorResult = comparator(item.properties[property])
                        ? comparatorName
                        : `${comparatorName} FAILED`;
                    item.properties[property] = isExpected ? comparatorName : comparatorResult;
                }
            });
        });
    }
    function _tryRender() {
        let render;
        const wNode = renderFunc();
        if (isWidgetFunction(widget)) {
            customDiffs.forEach((diff) => diff(properties, wNode.properties));
            propertiesDiff(properties, wNode.properties, () => {
                invalidated = true;
            }, [...customDiffNames]);
            if (children.length || wNode.children.length) {
                invalidated = true;
            }
            properties = Object.assign({}, wNode.properties);
            children = wNode.children;
            if (invalidated) {
                render = widget({ id: 'test', middleware, properties: () => properties, children: () => children });
            }
        }
        else {
            widget.__setProperties__(wNode.properties);
            widget.__setChildren__(wNode.children);
            if (invalidated) {
                render = widget.__render__();
            }
        }
        if (invalidated) {
            const { hasDeferredProperties, nodes } = decorateNodes(render);
            _runCompares(nodes);
            renderStack.push(nodes);
            if (hasDeferredProperties) {
                const { nodes: afterDeferredPropertiesNodes } = decorateNodes(render);
                _runCompares(afterDeferredPropertiesNodes);
                renderStack.push(afterDeferredPropertiesNodes);
            }
            invalidated = false;
        }
    }
    function _expect(expectedRenderFunc, actualRenderFunc, selector) {
        let renderResult;
        if (actualRenderFunc === undefined) {
            _tryRender();
            renderResult = _getRender();
        }
        else {
            renderResult = actualRenderFunc();
        }
        const { nodes: expectedRenderResult } = decorateNodes(expectedRenderFunc());
        _runCompares(expectedRenderResult, true);
        if (selector) {
            const [firstItem] = select(selector, renderResult);
            assertRender(firstItem, expectedRenderResult);
        }
        else {
            assertRender(renderResult, expectedRenderResult);
        }
    }
    return {
        expect(expectedRenderFunc, actualRenderFunc) {
            return _expect(expectedRenderFunc, actualRenderFunc);
        },
        expectPartial(selector, expectedRenderFunc, actualRenderFunc) {
            return _expect(expectedRenderFunc, actualRenderFunc, selector);
        },
        trigger(selector, functionSelector, ...args) {
            _tryRender();
            const [firstItem] = select(selector, _getRender());
            if (!firstItem) {
                throw new Error(`Cannot find node with selector ${selector}`);
            }
            let triggerFunction;
            if (typeof functionSelector === 'string') {
                triggerFunction = firstItem.properties[functionSelector];
            }
            else {
                triggerFunction = functionSelector(firstItem);
            }
            if (triggerFunction) {
                return triggerFunction.apply(widget, args);
            }
        },
        getRender(index) {
            return _getRender(index);
        }
    };
}
export default harness;
//# sourceMappingURL=harness.mjs.map