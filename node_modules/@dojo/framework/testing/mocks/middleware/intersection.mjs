import global from '../../../shim/global';
import { create, destroy, invalidator } from '../../../core/vdom';
import cache from '../../../core/middleware/cache';
import intersection from '../../../core/middleware/intersection';
export function createIntersectionMock() {
    const mockNodes = {};
    const refMap = new Map();
    const mockNode = {
        get(key) {
            return mockNodes[key];
        }
    };
    let invalidate;
    const factory = create({ destroy, cache, invalidator });
    const mockIntersectionFactory = factory(({ id, middleware, properties, children }) => {
        const { callback } = intersection();
        invalidate = middleware.invalidator;
        return callback({ id, middleware: Object.assign({}, middleware, { node: mockNode }), properties, children });
    });
    global.IntersectionObserver = class MockIntersection {
        constructor(cb) {
            this._cb = cb;
        }
        observe(ref) {
            this._ref = ref;
            refMap.set(ref, this);
            this._cb([Object.assign({}, ref, { target: this._ref })]);
        }
        intersection(intersectionDetails) {
            this._cb([Object.assign({}, intersectionDetails, { target: this._ref })]);
        }
    };
    function mockIntersection(key, intersectionDetails) {
        if (key) {
            if (!mockNodes[key]) {
                mockNodes[key] = intersectionDetails;
            }
            const ref = mockNodes[key];
            const mock = refMap.get(ref);
            if (mock) {
                mock.intersection(intersectionDetails);
            }
            else {
                invalidate && invalidate();
            }
        }
        else {
            return mockIntersectionFactory();
        }
    }
    return mockIntersection;
}
export default createIntersectionMock;
//# sourceMappingURL=intersection.mjs.map