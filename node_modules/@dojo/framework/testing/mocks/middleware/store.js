(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../../../core/vdom", "../../../core/middleware/injector", "../../../core/middleware/store", "../../../stores/Store"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vdom_1 = require("../../../core/vdom");
    var injector_1 = require("../../../core/middleware/injector");
    var store_1 = require("../../../core/middleware/store");
    var Store_1 = require("../../../stores/Store");
    var factory = vdom_1.create({ destroy: vdom_1.destroy, invalidator: vdom_1.invalidator, injector: injector_1.default });
    function createMockStoreMiddleware(processes) {
        if (processes === void 0) { processes = []; }
        var store = store_1.createStoreMiddleware();
        var storeMock = new Store_1.default();
        var processMockMap = new Map(processes);
        var injectorStub = {
            get: function () {
                return storeMock;
            },
            subscribe: function () { }
        };
        var mockStoreMiddleware = factory(function (_a) {
            var properties = _a.properties, _b = _a.middleware, destroy = _b.destroy, invalidator = _b.invalidator, children = _a.children, id = _a.id;
            var callback = store().callback;
            var mock = callback({
                id: id,
                middleware: { destroy: destroy, invalidator: invalidator, injector: injectorStub },
                properties: properties,
                children: children
            });
            return {
                get: mock.get.bind(mock),
                path: mock.path.bind(mock),
                executor: function (process) {
                    var mock = processMockMap.get(process);
                    if (mock) {
                        return mock;
                    }
                    return (function () { });
                },
                at: mock.at.bind(mock)
            };
        });
        function mockStore(operations) {
            if (operations) {
                storeMock.apply(operations(storeMock.path), true);
            }
            else {
                return mockStoreMiddleware();
            }
        }
        return mockStore;
    }
    exports.createMockStoreMiddleware = createMockStoreMiddleware;
    exports.default = createMockStoreMiddleware;
});
//# sourceMappingURL=store.js.map